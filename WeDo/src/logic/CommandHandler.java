package logic;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;



import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Multimap;

import dataStorage.DataHandler;
import definedEnumeration.TaskFeedBack;

/**
 * @author Kuan Tien Long This class handle all the commands passed in by the user
 * 
 */
public class CommandHandler {

    private DataHandler dataHandler;

    /**
     * Constructor for CommandHandler
     * 
     * @param dataHandler
     *            the handler which contains of all the data
     */
    public CommandHandler(DataHandler dataHandler) {
        this.dataHandler = dataHandler;
    }

    /**
     * Execute Command based on userInput
     * 
     * @param userInput
     *            the input to execute command
     * @return TaskFeedBack to continue or exit textBuddy
     */
    public TaskFeedBack executeCommand(String userInput) {

        Task task;
        StringBuilder userInputBuilder = new StringBuilder(userInput);
        TaskParserPlus taskParser = new TaskParserPlus();
        
       
        task = taskParser.buildTask(userInputBuilder);  
        Command command = getCommand(userInputBuilder.toString());
        
        if (command == null) 
        {
            return TaskFeedBack.FEEDBACK_INVALID;
        }
        
        command.dataHandler(dataHandler);
        command.setTask(task);        
        System.out.println(task);
        
        return command.execute();
    }

    /**
     * @param userInput
     * @return
     */
    private Command getCommand(String userInput) 
    {
        String possibleCommand = StringHandler.getFirstWord(userInput);
        return KeyMatcher.matchKey(createFakeMultiMap(), possibleCommand);
    }
    
    /**
     * This function create a map of commands and add them to the multi map. 
     * The real multi map will be generated by reading a file which consist the available action word to match
     */
    public Multimap<Command, String> createFakeMultiMap()
    {
        Multimap<Command, String> availableActions =  ArrayListMultimap.create();

        Command addCommand = new AddCommand();
        Command clearCommand = new ClearCommand();
        Command deleteCommand = new DeleteCommand();
        Command exitCommand = new ExitCommand();
        Command searchCommand = new SearchCommand();
        Command editCommand = new EditCommand();
        Command viewCommand = new ViewCommand();
        Command undoCommand = new UndoCommand();
        Command redoCommand = new RedoCommand();
        
        final Map<Command, Collection<String>> addActions = ImmutableMap.<Command, Collection<String>>of(
                addCommand, Arrays.asList("-add", "-a", "add", "-create", "-cre8"));
        final Map<Command, Collection<String>> clearActions = ImmutableMap.<Command, Collection<String>>of(
                clearCommand, Arrays.asList("-clear", "-cl", "-c", "-delete all", "-d all", "-clear screen", "clear"));
        final Map<Command, Collection<String>> deleteActions = ImmutableMap.<Command, Collection<String>>of(
                deleteCommand, Arrays.asList("-delete", "-d", "delete", "remove", "-remove"));
        final Map<Command, Collection<String>> exitActions = ImmutableMap.<Command, Collection<String>>of(
                exitCommand, Arrays.asList("-exit", "-e", "exit", "-quit", "-q", "quit", "alt qq", "leave", "-leave", "-bye"));
        final Map<Command, Collection<String>> searchActions = ImmutableMap.<Command, Collection<String>>of(
                searchCommand, Arrays.asList("-search", "search", "-s", "-find", "-f", "find"));
        final Map<Command, Collection<String>> editActions = ImmutableMap.<Command, Collection<String>>of(
                editCommand, Arrays.asList("-edit", "edit", "-e", "-modify", "-m", "modify"));
        final Map<Command, Collection<String>> viewActions = ImmutableMap.<Command, Collection<String>>of(
                viewCommand, Arrays.asList("-view", "view", "-v", "-read", "read", "-r"));
        final Map<Command, Collection<String>> undoActions = ImmutableMap.<Command, Collection<String>>of(
                undoCommand, Arrays.asList("-undo", "undo"));
        final Map<Command, Collection<String>> redoActions = ImmutableMap.<Command, Collection<String>>of(
                redoCommand, Arrays.asList("-redo", "redo"));
       
        
        addMapToMultiMap(addActions, availableActions);
        addMapToMultiMap(clearActions, availableActions);
        addMapToMultiMap(deleteActions, availableActions);
        addMapToMultiMap(exitActions, availableActions);
        addMapToMultiMap(searchActions, availableActions);
        addMapToMultiMap(editActions, availableActions);
        addMapToMultiMap(viewActions, availableActions);
        addMapToMultiMap(undoActions, availableActions);
        addMapToMultiMap(redoActions, availableActions);
        
        return availableActions;
    }

    private void addMapToMultiMap(final Map<Command, Collection<String>> map, Multimap<Command, String> availableActions) {
        for (Command key : map.keySet()) {
            availableActions.putAll(key, map.get(key));
          }
    }
    
    
}