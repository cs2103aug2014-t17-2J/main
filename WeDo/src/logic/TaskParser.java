/**
 * 
 */
package logic;

import java.util.Arrays;
import java.util.Collection;
import java.util.Map;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Multimap;

/**
 * @author Kuan Tien Long
 *
 */
public class TaskParser {
    
    private final String actionsDelimiter = "-";
  
    
    public TaskParser()
    {
        createFakeMultiMap(); 
    }
    
    public Task buildTask(String userInput) throws MyException
    {
        String[] actionsTokens = StringHandler.splitString(userInput,
                actionsDelimiter);
        
        Task task = createTask(actionsTokens);
        System.out.println(Arrays.toString(actionsTokens));

        return task;

    }
    
    /**
     * This function create a map of commands and add them to the multi map. 
     * The real multi map will be generated by reading a file which consist the available action word to match
     */
    public Multimap<TaskAttribute, String> createFakeMultiMap()
    {
        Multimap<TaskAttribute, String> availableActions =  ArrayListMultimap.create();
        TaskPriorityAttribute priorityCommand = new TaskPriorityAttribute();
        TaskDateAttribute dateCommand = new TaskDateAttribute();

       
        final Map<TaskAttribute, Collection<String>> dateActions = ImmutableMap.<TaskAttribute, Collection<String>>of(
                dateCommand, Arrays.asList("date", "day", "d", "month", "time"));
        final Map<TaskAttribute, Collection<String>> priorityActions = ImmutableMap.<TaskAttribute, Collection<String>>of(
                priorityCommand, Arrays.asList("priority", "pri", "p"));
        
        
        addMapToMultiMap(dateActions, availableActions);
        addMapToMultiMap(priorityActions, availableActions);
        
        return availableActions;
    }

    private void addMapToMultiMap(final Map<TaskAttribute, Collection<String>> map, Multimap<TaskAttribute, String> availableActions) {
        for (TaskAttribute key : map.keySet()) {
            availableActions.putAll(key, map.get(key));
          }
    }

    /**
     * @param commandTokens
     * @return
     */
    private Task createTask(String[] actionTokens) throws MyException
    {
        Task task = new Task();
        boolean initial = true;
        enableSearching();
        
        for(String token : actionTokens )
        {
            if (initial == true)
            {
                setDescription(token, task);
                initial = false;
            }
            else
            {
            setTaskAttribute(token, task);
            }
        }
        
        return task;
    }

    /**
     * @param token
     * @param task
     */
    private void setDescription(String token, Task task) 
    {
        String operation = StringHandler.getFirstWord(token);
        String arguments = StringHandler.removeFirstMatched(token, operation);
        TaskAttribute taskAttribute = new TaskDescriptionAttribute();
        taskAttribute.set(task, arguments);
    }

    /**
     * @param tokens
     */
    private void setTaskAttribute(String token, Task task) throws MyException
    {
        String operation = StringHandler.getFirstWord(token);
        String arguments = StringHandler.removeFirstMatched(token, operation);
        TaskAttribute taskAttribute = determineAttribute(operation);
        if(taskAttribute == null)
        {
            throw new MyException("No such command :" + operation);
        }
        taskAttribute.set(task, arguments);
        
        System.out.println("Opeartion :" + operation + "  arguments : " + arguments); 
    }

    /**
     * @param operation
     * @return 
     */
    private TaskAttribute determineAttribute(String operation) 
    {
        return KeyMatcher.matchKey(createFakeMultiMap(), operation);        
    }
    
    
    private boolean canSearchCommand;
    private boolean canSearchDate;
    private boolean canSearchPriority;
    
    
    private void enableSearching()
    {
        canSearchCommand = true;
        canSearchDate = true;
        canSearchPriority = true;
    }
    
    private boolean isCommandAction()
    {
        if(!canSearchCommand)
        {
            return false;
        }
        else
        {
            disableRepeatedSearch(canSearchCommand);
            return true;
        }
    }

    private void disableRepeatedSearch(boolean searchOpeartion) 
    {
        searchOpeartion = false;
    }
    
    private boolean isDateAction()
    {
        if(!canSearchDate)
        {
            return false;
        }
        else
        {
            disableRepeatedSearch(canSearchDate);
            return true;
        }
    }

    private boolean isPriorityAction()
    {
        if(!canSearchPriority)
        {
            return false;
        }
        else
        {
            disableRepeatedSearch(canSearchPriority);
            return true;
        }
    }
    
    
    private boolean isInvalidAction()
    {
        return true;
    }
}