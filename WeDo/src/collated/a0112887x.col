//@author: a0112887x



	/**
	 * origin: brain\ProcessorV2.java
	 */

/**
 *
 */
public class ProcessorV2 {

    public static void main(String[] args) {

        DataHandler dataHandler = new BasicDataHandler();
        ObservableList<Task> observableList = dataHandler.getObservableList();
        LogicManager logicManager = new LogicManager(dataHandler);
        UserIntSwing swi = new UserIntSwing(logicManager, observableList);
        observableList.addObserver(swi);
        swi.execute();
    }
}
	// End of segment: brain\ProcessorV2.java





	/**
	 * origin: dataStorage\ObservableList.java
	 */

/**
 * 
 * This class consist the observable list which update it's observers whenever a
 * modification occurs The possible modification includes : <li>add <li>delete
 * <li>edit <li>replace list
 * <p>
 * <br>
 * 
 * 
 * @param <T>
 *            the list type
 */
public class ObservableList<T> extends Observable {
    private ArrayList<T> observedList;

    public ObservableList(ArrayList<T> list) {
        observedList = list;
    }

    /**
     * @return whether if the list is null
     */
    private boolean isNull() {
        return observedList == null;
    }

    /**
     * @return whether if the list is empty
     */
    private boolean isEmpty() {
        return observedList.isEmpty();
    }

    /**
     * This function add the argument to the specified index of the list and
     * update the observer(s) with the argument
     * 
     * @param argument
     *            to be added to the list
     * @return boolean if the operation is successful
     */
    public boolean add(int index, T argument) {
        if (isNull()) {
            return false;
        }
        observedList.add(index, argument);
        setChanged();
        notifyObservers(argument);
        return true;
    }

    /**
     * This function add the argument to the list and update the observer(s)
     * with the argument
     * 
     * @param argument
     *            to be added to the list
     * @return boolean if the operation is successful
     */
    public boolean add(T argument) {
        if (isNull()) {
            return false;
        }
        observedList.add(argument);
        setChanged();
        notifyObservers(argument);
        return true;
    }

    /**
     * This function delete the specified index of the list and update the
     * observer(s) about with the deleted argument
     * 
     * @param index
     *            to be deleted from the list
     * @return boolean if the operation is successful
     */
    public boolean remove(int index) {
        T deleted;
        if (isNull() || isEmpty()) {
            return false;
        }
        try {
            deleted = observedList.remove(index);
        } catch (IndexOutOfBoundsException exception) {
            return false;
        }
        setChanged();
        notifyObservers(deleted);
        return true;
    }

    /**
     * This function delete the specified argument of the list and update the
     * observer(s) about with the deleted argument
     * 
     * @param argument
     *            to be deleted from the list
     * @return boolean if the operation is successful
     */
    public boolean remove(T argument) {

        boolean succeed;

        if (isNull() || isEmpty()) {
            return false;
        }
        try {
            succeed = observedList.remove(argument);
        } catch (IndexOutOfBoundsException exception) {
            return false;
        }

        setChanged();
        notifyObservers(argument);
        return succeed;
    }

    /**
     * This function edit the specified index of the list with the argument. <br>
     * In addition, it also updates the observer(s) about with the edited
     * argument
     * 
     * @param index
     *            that is to be selected for editing
     * @param argument
     *            that will be replacing the initial information
     * @return boolean if the operation is successful
     */
    public boolean edit(int index, T argument) {
        try {
            observedList.set(index, argument);
        } catch (IndexOutOfBoundsException exception) {
            return false;
        }
        setChanged();
        notifyObservers(argument);
        return true;
    }

    /**
     * This function edit the task inside the list <br>
     * In addition, it also updates the observer(s) about with the edited
     * argument
     * 
     * @param argument
     *            that will be replacing the initial information
     * @return boolean if the operation is successful
     */
    public boolean edit(T argument) {
        try {
            int index = observedList.indexOf(argument);
            edit(index, argument);
        } catch (IndexOutOfBoundsException exception) {
            return false;
        }

        return true;
    }

    /**
     * @param argument
     * @return
     */
    public int indexOf(T argument) {
        assert (observedList != null);
        return observedList.indexOf(argument);
    }

    /**
     * This function replaces the entire list. <br>
     * In addition, it also updates the observer with the new list
     * 
     * @param newList
     *            which will be used to replace the initial list.
     */
    public void replaceList(ArrayList<T> newList) {
        observedList = newList;
        setChanged();
        notifyObservers(newList);
    }

    /**
     * This function retrieve the argument from the specified index of the list
     * 
     * @param index
     *            of the argument to return
     * @return the argument at the specified index or null if there's no
     *         argument at the specified index
     */
    public T get(int index) {
        T result;
        try {
            result = observedList.get(index);
        } catch (IndexOutOfBoundsException | NullPointerException exception) {
            return null;
        }
        return result;
    }

    /**
     * Remove all elements in the list
     */
    public void clearList() {
        observedList.clear();
    }

    /**
     * @return the stored list
     */
    public ArrayList<T> getList() {
        return observedList;

    }

    /**
     * This function add observer to the list. <br>
     * The observer will be updated when modification to the list is made
     * 
     * @param observer
     *            that will be added to observed the modification in the list
     */
    public void addObserverList(Observer observer) {
        this.addObserver(observer);
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        ObservableList<?> other = (ObservableList<?>) obj;
        if (observedList == null) {
            if (other.observedList != null)
                return false;
        } else if (!observedList.equals(other.observedList))
            return false;
        return true;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return "ObservableList [observedList=" + observedList + "]";
    }
}

	// End of segment: dataStorage\ObservableList.java





	/**
	 * origin: definedEnumeration\Priority.java
	 */

/**
 * Provides the priority level for task
 */
public enum Priority {
    PRIORITY_HIGH("High"), PRIORITY_MEDIUM("Medium"), PRIORITY_LOW("Low"), PRIORITY_UNDEFINED(
            "");

    private final String priorityLevel;

    /**
     * Set the string for the corresponding priority level
     * @param priorityLevel the priority level to set
     */
    private Priority(String priorityLevel) {
        this.priorityLevel = priorityLevel;
    }

    public String toString() {
        return priorityLevel;
    }

}

	// End of segment: definedEnumeration\Priority.java





	/**
	 * origin: logic\command\CommandExecutor.java
	 */

/**
 * This class handle all the commands passed in by the user
 * 
 */
public class CommandExecutor {

    private DataHandler dataHandler;

    /**
     * Constructor for CommandHandler
     * 
     * @param dataHandler
     *            the handler which contains of all the data
     */
    public CommandExecutor(DataHandler dataHandler) {
        this.dataHandler = dataHandler;
    }

    /**
     * Execute the command such as add, view etc
     * @param command
     *            the command to execute
     * @param task
     *            the task to execute
     * @return
     * @throws InvalidCommandException
     */
    public void execute(Command command, Task task)
            throws InvalidCommandException {

        assert(command != null);
        assert(dataHandler != task);

        command.setDataHandler(dataHandler);
        command.setTask(task);
        System.out.println(task);

        command.execute();
    }

}

	// End of segment: logic\command\CommandExecutor.java





	/**
	 * origin: logic\command\commandList\AddCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for AddTask
 */

public class AddCommand extends Command {

    /* (non-Javadoc)
     * @see logic.command.commandList.Command#execute()
     */
    public void execute() throws InvalidCommandException {
        final String ERROR_MESSAGE = "Adding failed";
        assert(dataHandler != null);
        if (dataHandler.addTask(task)) {
            undoHandler.addUndo(this);
        } else {
            throw new InvalidCommandException(ERROR_MESSAGE);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() {
        assert(dataHandler != null);
        dataHandler.removeTask(task);

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(logic.parser.ParserFlags)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        return isParseValidForAdd(parseFlags);

    }

    /**
     * <p>
     * Determine whether the parse occurred was valid by matching it with
     * VALID_PARSE which contains compulsory parse result(s) for add command
     * required
     * <p>
     * 
     * @param parseFlags
     *            the set of ParserFlag to be tested
     * @return if it contains all of the VALID_ADD_SET flag
     */
    public boolean isParseValidForAdd(EnumSet<ParserFlags> parseFlags) {

        final EnumSet<ParserFlags> VALID_PARSE = EnumSet.of(
                ParserFlags.DESCRIPTION_FLAG, ParserFlags.COMMAND_FLAG);

        if (parseFlags.containsAll(VALID_PARSE)) {
            return true;
        } else {
            return false;
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Add";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of add should contains description field";
        return ERROR_MESSAGE;
    }

}

	// End of segment: logic\command\commandList\AddCommand.java





	/**
	 * origin: logic\command\commandList\Command.java
	 */

/**
 * Abstract class that all commands must extend
 *
 */
public abstract class Command {

    protected Task task;
    protected DataHandler dataHandler;
    protected UndoHandler undoHandler = UndoHandler.getInstance();
    

    public void setTask(Task task) {
        this.task = task;
    }

    /**
     * Set the dataHandler for the command
     * @param dataHandler the dataHandler to set
     */
    public void setDataHandler(DataHandler dataHandler) {
        this.dataHandler = dataHandler;
    }

    /**
     * Execute the command such as add, view etc.
     * @throws InvalidCommandException when command is invalid
     */
    public abstract void execute() throws InvalidCommandException;

    /**
     * undo the command executed
     * @throws InvalidCommandException 
     */
    public abstract void undo() throws InvalidCommandException;

    /**
     * <p>
     * Determine whether the parse occurred was valid
     * <p>
     * 
     * @param parseFlags
     *            the set of ParserFlag to be tested
     * @return if what is parsed is valid for the command
     */
    public abstract boolean validate(EnumSet<ParserFlags> parseFlags);

    /**
     * Get validation error message from the command
     * 
     * @return Error Message
     */
    public abstract String getValidateErrorMessage();

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Command other = (Command) obj;
        if (dataHandler == null) {
            if (other.dataHandler != null)
                return false;
        } else if (!dataHandler.equals(other.dataHandler))
            return false;
        if (task == null) {
            if (other.task != null)
                return false;
        } else if (!task.equals(other.task))
            return false;
        if (undoHandler == null) {
            if (other.undoHandler != null)
                return false;
        } else if (!undoHandler.equals(other.undoHandler))
            return false;
        return true;
    }

    /* (non-Javadoc)
     * @see java.lang.Object#toString()
     */
    public abstract String toString();

}

	// End of segment: logic\command\commandList\Command.java





	/**
	 * origin: logic\command\commandList\CompleteCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for ClearTask
 */
public class CompleteCommand extends Command {
    ArrayList<Task> editTaskList = new ArrayList<Task>();

    public void execute() throws InvalidCommandException {

        assert(dataHandler != null);
        
        final int ARRAY_OFFSET = 1;
        final String NO_INTEGER_EXTRACTED = "No integer extracted";
        final String INVALID_LOWEST_INDEX = "Invalid lowest index";
        final String INVALID_HIGHEST_INDEX = "Invalid highest index";

        TreeSet<Integer> digitList = extractAllDigits(task.getDescription());

        if (digitList.isEmpty()) {
            throw new InvalidCommandException(NO_INTEGER_EXTRACTED);
        }

        if (!dataHandler.indexValid(digitList.first() - ARRAY_OFFSET)) {
            throw new InvalidCommandException(INVALID_LOWEST_INDEX);
        }

        if (!dataHandler.indexValid(digitList.last() - ARRAY_OFFSET)) {
            throw new InvalidCommandException(INVALID_HIGHEST_INDEX);
        }

        editTaskList = getTasksToComplete(ARRAY_OFFSET, digitList);
        completeTask(editTaskList);

        undoHandler.addUndo(this);

    }

    /**
     * Complete all the task at completeTaskList
     * 
     * @param editTaskList
     *            the list of task to delete
     */
    private void completeTask(ArrayList<Task> editTaskList) {
        final boolean COMPLETE = true;
        
        assert(dataHandler != null);
        
        for (Task task : editTaskList) {
            dataHandler.setCompleteTask(task, COMPLETE);
        }
    }

    /**
     * Get all task to be completed
     * 
     * @param ARRAY_OFFSET
     *            the offset for array
     * @param digitList
     *            which contains of all the index to delete
     * @return the list of task to delete
     */
    private ArrayList<Task> getTasksToComplete(final int ARRAY_OFFSET,
            TreeSet<Integer> digitList) {

        ArrayList<Task> completeTaskList = new ArrayList<Task>();
        assert(dataHandler != null);
        
        for (int index : digitList) {
            Task taskToDelete = dataHandler.getTask(index - ARRAY_OFFSET);
            completeTaskList.add(taskToDelete);
        }

        return completeTaskList;
    }

    /**
     * Extract all digits from the string
     * 
     * @param source
     *            the string which contains the digits
     * @return TreeSet<Integer> which contains all the digits extracted
     */
    private TreeSet<Integer> extractAllDigits(String source) {

        TreeSet<Integer> extractedDigitList = new TreeSet<Integer>();

        String digitPatterns = "(-{0,1}[0-9]+)\\s*(?:to|-)\\s*(-{0,1}[0-9]+)|(-{0,1}[0-9]+)";
        final int START_RANGE_GROUP = 1;
        final int END_RANGE_GROUP = 2;
        final int INDIVIDUAL_DIGIT_GROUP = 3;

        Pattern pattern = Pattern.compile(digitPatterns);
        Matcher matcher = pattern.matcher(source);

        while (matcher.find()) {
            if (matcher.group(START_RANGE_GROUP) != null
                    && matcher.group(END_RANGE_GROUP) != null) {
                int startRange = StringHandler.parseStringToInteger(matcher
                        .group(START_RANGE_GROUP));
                int endRange = StringHandler.parseStringToInteger(matcher
                        .group(END_RANGE_GROUP));
                for (int index = startRange; index <= endRange; index++) {
                    extractedDigitList.add(index);
                }
            }

            if (matcher.group(INDIVIDUAL_DIGIT_GROUP) != null) {
                int index = StringHandler.parseStringToInteger(matcher
                        .group(INDIVIDUAL_DIGIT_GROUP));
                extractedDigitList.add(index);
            }
        }

        return extractedDigitList;

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() {
        setIncomplete(editTaskList);

    }

    /**
     * Add the previously removed task back
     * 
     * @param undoTaskList
     *            the list of task that was deleted
     */
    private void setIncomplete(ArrayList<Task> undoTaskList) {
        final boolean COMPLETE = false;
        assert(dataHandler != null);
        
        for (Task task : editTaskList) {
            dataHandler.setCompleteTask(task, COMPLETE);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {

        final EnumSet<ParserFlags> VALID_COMPLETE_PARSE = EnumSet.of(
                ParserFlags.DESCRIPTION_FLAG, ParserFlags.COMMAND_FLAG);

        return ParserFlags.containsOnly(parseFlags, VALID_COMPLETE_PARSE);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Completed";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of complete should only be <Complete> <Index>";
        return ERROR_MESSAGE;
    }

}
	// End of segment: logic\command\commandList\CompleteCommand.java





	/**
	 * origin: logic\command\commandList\DeleteCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for DeleteTask
 */
public class DeleteCommand extends Command {

    ArrayList<Task> deleteTaskList = new ArrayList<Task>();

    /* (non-Javadoc)
     * @see logic.command.commandList.Command#execute()
     */
    public void execute() throws InvalidCommandException {

        assert(dataHandler != null);
       
        final int ARRAY_OFFSET = 1;
        final String NO_INTEGER_EXTRACTED = "No integer extracted";
        final String INVALID_LOWEST_INDEX = "Invalid lowest index";
        final String INVALID_HIGHEST_INDEX = "Invalid highest index";

        TreeSet<Integer> digitList = extractAllDigits(task.getDescription());

        if (digitList.isEmpty()) {
            throw new InvalidCommandException(NO_INTEGER_EXTRACTED);
        }

        if (!dataHandler.indexValid(digitList.first() - ARRAY_OFFSET)) {
            throw new InvalidCommandException(INVALID_LOWEST_INDEX);
        }

        if (!dataHandler.indexValid(digitList.last() - ARRAY_OFFSET)) {
            throw new InvalidCommandException(INVALID_HIGHEST_INDEX);
        }

        deleteTaskList = getTasksToDelete(ARRAY_OFFSET, digitList);
        removeTasks(deleteTaskList);

        undoHandler.addUndo(this);

    }

    /**
     * Delete all the task at deleteTaskList
     * 
     * @param deleteTaskList
     *            the list of task to delete
     */
    private void removeTasks(ArrayList<Task> deleteTaskList) {
        
        assert(dataHandler != null);
        
        for (Task deleteThisTask : deleteTaskList) {
            dataHandler.removeTask(deleteThisTask);
        }
    }

    /**
     * Get all task to be deleted
     * 
     * @param ARRAY_OFFSET
     *            the offset for array
     * @param digitList
     *            which contains of all the index to delete
     * @return the list of task to delete
     */
    private ArrayList<Task> getTasksToDelete(final int ARRAY_OFFSET,
            TreeSet<Integer> digitList) {

        ArrayList<Task> deleteTaskList = new ArrayList<Task>();
        
        assert(dataHandler != null);
        

        for (int index : digitList) {
            Task taskToDelete = dataHandler.getTask(index - ARRAY_OFFSET);
            deleteTaskList.add(taskToDelete);
        }

        return deleteTaskList;
    }

    /**
     * Extract all digits from the string
     * 
     * @param source
     *            the string which contains the digits
     * @return TreeSet<Integer> which contains all the digits extracted
     */
    private TreeSet<Integer> extractAllDigits(String source) {

        TreeSet<Integer> extractedDigitList = new TreeSet<Integer>();

        String digitRegex = "(-{0,1}[0-9]+)\\s*(?:to|-)\\s*(-{0,1}[0-9]+)|(-{0,1}[0-9]+)";
        final int START_RANGE_GROUP = 1;
        final int END_RANGE_GROUP = 2;
        final int INDIVIDUAL_DIGIT_GROUP = 3;

        Pattern pattern = Pattern.compile(digitRegex);
        Matcher matcher = pattern.matcher(source);

        while (matcher.find()) {
            if (matcher.group(START_RANGE_GROUP) != null
                    && matcher.group(END_RANGE_GROUP) != null) {
                int startRange = StringHandler.parseStringToInteger(matcher
                        .group(START_RANGE_GROUP));
                int endRange = StringHandler.parseStringToInteger(matcher
                        .group(END_RANGE_GROUP));
                for (int index = startRange; index <= endRange; index++) {
                    extractedDigitList.add(index);
                }
            }

            if (matcher.group(INDIVIDUAL_DIGIT_GROUP) != null) {
                int index = StringHandler.parseStringToInteger(matcher
                        .group(INDIVIDUAL_DIGIT_GROUP));
                extractedDigitList.add(index);
            }
        }

        return extractedDigitList;

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() throws InvalidCommandException {
        addRemovedTasks(deleteTaskList);
    }

    /**
     * Add the previously removed task back
     * 
     * @param deleteTaskList
     *            the list of task that was deleted
     * @throws InvalidCommandException 
     */
    private void addRemovedTasks(ArrayList<Task> deleteTaskList) throws InvalidCommandException {
        assert(dataHandler != null);
        
        for (Task taskToReAdd : deleteTaskList) {
            dataHandler.addTask(taskToReAdd);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        final EnumSet<ParserFlags> VALID_DELETE_PARSE = EnumSet.of(
                ParserFlags.DESCRIPTION_FLAG, ParserFlags.COMMAND_FLAG);

        return ParserFlags.containsOnly(parseFlags, VALID_DELETE_PARSE);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Delete";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of delete should only be <Delete> <Index>";
        return ERROR_MESSAGE;
    }

}

	// End of segment: logic\command\commandList\DeleteCommand.java





	/**
	 * origin: logic\command\commandList\EditCommand.java
	 */

/**
 * TienLong This class makes use of the Command interface to implement execute
 * function for edit
 */
public class EditCommand extends Command {

    private static final int NOT_SET = -1;

    private int index = NOT_SET;
    private Task source;

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#execute()
     */
    public void execute() throws InvalidCommandException {

        assert (dataHandler != null);

        final String ERROR_MESSAGE = "Edit failed, invalid index";
        if (index == NOT_SET) {
            String indexString = StringHandler.getIntegerFromFirstSlot(task
                    .getDescription());

            if (indexString == null) {
            }

            index = getIndex(indexString);

            if (!dataHandler.indexValid(index)) {
                throw new InvalidCommandException(ERROR_MESSAGE);
            }

            task.setDescription(StringHandler.removeFirstMatched(
                    task.getDescription(), indexString));

            source = dataHandler.getTask(index);

        }

        if (!dataHandler.indexValid(index)) {
            throw new InvalidCommandException(ERROR_MESSAGE);
        }

        task = editSpecifiedField(source, task);

        dataHandler.editTask(source, task);
        undoHandler.addUndo(this);

    }

    /**
     * Edit the source task based on specified field that the user enter
     * 
     * @param source
     *            the task that the user wanted to edit
     * @param toEditTask
     *            the task that the user enter
     * @return editedTask based on what user had specified
     */
    private Task editSpecifiedField(Task source, Task toEditTask) {
        Task editedTask = new Task();
        boolean somedaySpecified = false;

        Collection<String> someDayCollection = KeyWordMappingList
                .getSomeDayKeyWord().get(Task.DATE_NOT_SET);
        String[] someDayKeyWords = (String[]) someDayCollection.toArray();

        somedaySpecified = isSomeDaySpecified(toEditTask, someDayKeyWords);

        if (somedaySpecified) {
            removeSomeDayKeyWord(toEditTask, someDayKeyWords);
        }

        setDescriptionBasedOnSpecified(source, toEditTask, editedTask);

        setPriorityBasedOnSpecified(source, toEditTask, editedTask);

        setDateTimeBasedOnSpecified(source, toEditTask, editedTask);

        setCompleteStatus(source, editedTask);

        if (somedaySpecified) {
            setSomeday(editedTask);
        }

        return editedTask;
    }

    /**
     * Set the task to someday
     * 
     * @param editedTask
     *            the task to be set to someday
     */
    private void setSomeday(Task editedTask) {
        editedTask.setEndDate(Task.DATE_NOT_SET);
        editedTask.setStartDate(Task.DATE_NOT_SET);
        editedTask.setEndTime(Task.TIME_NOT_SET);
        editedTask.setStartTime(Task.TIME_NOT_SET);
    }

    /**
     * Remove the some day keyword from the description
     * 
     * @param toEditTask
     *            the task to edit
     * @param someDayKeyWords
     *            the keywords for someday
     */
    private void removeSomeDayKeyWord(Task toEditTask, String[] someDayKeyWords) {
        String matchedWord = StringHandler.getContainsWord(
                toEditTask.getDescription(), someDayKeyWords);
        String newDescription = StringHandler.removeFirstMatchedWord(
                toEditTask.getDescription(), matchedWord);

        toEditTask.setDescription(newDescription);
    }

    /**
     * Check if someday is specified
     * 
     * @param toEditTask
     *            the task to edit
     * @param someDayKeyWords
     *            the keywords for someday
     * @return if someday is specified
     */
    private boolean isSomeDaySpecified(Task toEditTask, String[] someDayKeyWords) {
        boolean somedaySpecified;

        if (toEditTask.getDescription() != null) {
            if (StringHandler.containsWord(toEditTask.getDescription(),
                    someDayKeyWords)) {
                somedaySpecified = true;

            } else
                somedaySpecified = false;
        } else {
            somedaySpecified = false;
        }

        return somedaySpecified;
    }

    /**
     * Set complete status for the task
     * 
     * @param source
     *            from the task that will be edited
     * @param editedTask
     *            the task that contains what to edit
     */
    private void setCompleteStatus(Task source, Task editedTask) {
        editedTask.setCompleted(source.getCompleted());
    }

    /**
     * Set date for the task
     * 
     * @param source
     *            from the task that will be edited
     * @param editedTask
     *            the task that contains what to edit
     */
    private void setDateTimeBasedOnSpecified(Task source, Task toEditTask,
            Task editedTask) {
        if (toEditTask.getEndDate() == null
                || toEditTask.getEndDate() == Task.DATE_NOT_SET) {
            editedTask.setEndDate(source.getEndDate());
        } else {
            editedTask.setEndDate(toEditTask.getEndDate());
        }

        if (toEditTask.getStartDate() == null
                || toEditTask.getStartDate() == Task.DATE_NOT_SET) {
            editedTask.setStartDate(source.getStartDate());
        } else {
            editedTask.setStartDate(toEditTask.getStartDate());
        }

        if (toEditTask.getStartTime() == null
                || toEditTask.getStartTime() == Task.TIME_NOT_SET) {
            editedTask.setStartTime(source.getStartTime());
        } else {
            editedTask.setStartTime(toEditTask.getStartTime());
        }

        if (toEditTask.getEndTime() == null
                || toEditTask.getEndTime() == Task.TIME_NOT_SET) {
            editedTask.setEndTime(source.getEndTime());
        } else {
            editedTask.setEndTime(toEditTask.getEndTime());
        }
    }

    /**
     * Set priority status for the task
     * 
     * @param source
     *            from the task that will be edited
     * @param editedTask
     *            the task that contains what to edit
     */
    private void setPriorityBasedOnSpecified(Task source, Task toEditTask,
            Task editedTask) {
        if (toEditTask.getPriority() == null
                || toEditTask.getPriority() == Task.PRIORITY_NOT_SET) {
            editedTask.setPriority(source.getPriority());
        } else {
            editedTask.setPriority(toEditTask.getPriority());
        }
    }

    /**
     * Set description for the task
     * 
     * @param source
     *            from the task that will be edited
     * @param editedTask
     *            the task that contains what to edit
     */
    private void setDescriptionBasedOnSpecified(Task source, Task toEditTask,
            Task editedTask) {
        if (toEditTask.getDescription() == null
                || toEditTask.getDescription().isEmpty()) {
            editedTask.setDescription(source.getDescription());
        } else {
            editedTask.setDescription(toEditTask.getDescription());
        }
    }

    /**
     * Parse integer from the string
     * 
     * @param indexString
     *            the string which contains the index
     * @return the integer parsed from the string
     */
    private int getIndex(String indexString) {
        final int ARRAY_OFFSET = -1;
        return StringHandler.parseStringToInteger(indexString) + ARRAY_OFFSET;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() throws InvalidCommandException {
        assert (dataHandler != null);

        dataHandler.editTask(task, source);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        final int MAX_VALID_FLAG = 1;
        return parseFlags.size() > MAX_VALID_FLAG;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Edit";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of edit should consist at least 1 field to edit";
        return ERROR_MESSAGE;
    }

    /**
     * @param source
     *            the source to set
     */
    public void setSource(Task source) {
        this.source = source;
    }
}

	// End of segment: logic\command\commandList\EditCommand.java





	/**
	 * origin: logic\command\commandList\ExitCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for ExitTask
 */
public class ExitCommand extends Command {

    /* (non-Javadoc)
     * @see logic.command.commandList.Command#execute()
     */
    public void execute() throws InvalidCommandException {
        System.exit(0);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo() No undo for exit.
     */
    @Override
    public void undo() {

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        final EnumSet<ParserFlags> VALID_EXIT_PARSE = EnumSet
                .of(ParserFlags.COMMAND_FLAG);

        return ParserFlags.containsOnly(parseFlags, VALID_EXIT_PARSE);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Exit";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of exit should only be <Exit>";
        return ERROR_MESSAGE;
    }
}

	// End of segment: logic\command\commandList\ExitCommand.java





	/**
	 * origin: logic\command\commandList\IncompleteCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for ClearTask
 */
public class IncompleteCommand extends Command {
    ArrayList<Task> editTaskList = new ArrayList<Task>();

    public void execute() throws InvalidCommandException {

        assert(dataHandler != null);
        
        final int ARRAY_OFFSET = 1;
        final String NO_INTEGER_EXTRACTED = "No integer extracted";
        final String INVALID_LOWEST_INDEX = "Invalid lowest index";
        final String INVALID_HIGHEST_INDEX = "Invalid highest index";

        TreeSet<Integer> digitList = extractAllDigits(task.getDescription());

        if (digitList.isEmpty()) {
            throw new InvalidCommandException(NO_INTEGER_EXTRACTED);
        }

        if (!dataHandler.indexValid(digitList.first() - ARRAY_OFFSET)) {
            throw new InvalidCommandException(INVALID_LOWEST_INDEX);
        }

        if (!dataHandler.indexValid(digitList.last() - ARRAY_OFFSET)) {
            throw new InvalidCommandException(INVALID_HIGHEST_INDEX);
        }

        editTaskList = getTasksToComplete(ARRAY_OFFSET, digitList);
        inCompleteTask(editTaskList);

        undoHandler.addUndo(this);

    }

    /**
     * Incomplete all the task at completeTaskList
     * 
     * @param editTaskList
     *            the list of task to delete
     */
    private void inCompleteTask(ArrayList<Task> editTaskList) {
        final boolean COMPLETE = false;

        assert(dataHandler != null);
        
        for (Task task : editTaskList) {
            dataHandler.setCompleteTask(task, COMPLETE);
        }
    }

    /**
     * Get all task to be completed
     * 
     * @param ARRAY_OFFSET
     *            the offset for array
     * @param digitList
     *            which contains of all the index to delete
     * @return the list of task to delete
     */
    private ArrayList<Task> getTasksToComplete(final int ARRAY_OFFSET,
            TreeSet<Integer> digitList) {

        assert(dataHandler != null);
        
        ArrayList<Task> completeTaskList = new ArrayList<Task>();

        for (int index : digitList) {
            Task taskToDelete = dataHandler.getTask(index - ARRAY_OFFSET);
            completeTaskList.add(taskToDelete);
        }

        return completeTaskList;
    }

    /**
     * Extract all digits from the string
     * 
     * @param source
     *            the string which contains the digits
     * @return TreeSet<Integer> which contains all the digits extracted
     */
    private TreeSet<Integer> extractAllDigits(String source) {

        TreeSet<Integer> extractedDigitList = new TreeSet<Integer>();

        String digitPattern = "(-{0,1}[0-9]+)\\s*(?:to|-)\\s*(-{0,1}[0-9]+)|(-{0,1}[0-9]+)";
        final int START_RANGE_GROUP = 1;
        final int END_RANGE_GROUP = 2;
        final int INDIVIDUAL_DIGIT_GROUP = 3;

        Pattern pattern = Pattern.compile(digitPattern);
        Matcher matcher = pattern.matcher(source);

        while (matcher.find()) {
            if (matcher.group(START_RANGE_GROUP) != null
                    && matcher.group(END_RANGE_GROUP) != null) {
                int startRange = StringHandler.parseStringToInteger(matcher
                        .group(START_RANGE_GROUP));
                int endRange = StringHandler.parseStringToInteger(matcher
                        .group(END_RANGE_GROUP));
                for (int index = startRange; index <= endRange; index++) {
                    extractedDigitList.add(index);
                }
            }

            if (matcher.group(INDIVIDUAL_DIGIT_GROUP) != null) {
                int index = StringHandler.parseStringToInteger(matcher
                        .group(INDIVIDUAL_DIGIT_GROUP));
                extractedDigitList.add(index);
            }
        }

        return extractedDigitList;

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() {
        setComplete(editTaskList);

    }

    /**
     * Add the previously removed task back
     * 
     * @param undoTaskList
     *            the list of task that was deleted
     */
    private void setComplete(ArrayList<Task> undoTaskList) {
        final boolean COMPLETE = true;

        assert(dataHandler != null);
        
        for (Task task : editTaskList) {
            dataHandler.setCompleteTask(task, COMPLETE);
        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {

        final EnumSet<ParserFlags> VALID_UNCOMPLETE_PARSE = EnumSet.of(
                ParserFlags.DESCRIPTION_FLAG, ParserFlags.COMMAND_FLAG);

        return ParserFlags.containsOnly(parseFlags, VALID_UNCOMPLETE_PARSE);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        String COMMAND_NAME = "Completed";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of complete should only be <Uncomplete> <Index>";
        return ERROR_MESSAGE;
    }

}
	// End of segment: logic\command\commandList\IncompleteCommand.java





	/**
	 * origin: logic\command\commandList\RedoCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for undoCommand
 */
public class RedoCommand extends Command {

    public void execute() throws InvalidCommandException {
        undoHandler.redo();
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() {
        // TODO Auto-generated method stub

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        final EnumSet<ParserFlags> VALID_REDO_PARSE = EnumSet
                .of(ParserFlags.COMMAND_FLAG);

        return ParserFlags.containsOnly(parseFlags, VALID_REDO_PARSE);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Redo";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of redo should only be <Redo>";
        return ERROR_MESSAGE;
    }
}

	// End of segment: logic\command\commandList\RedoCommand.java





	/**
	 * origin: logic\command\commandList\SearchCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for searchTask
 */
public class SearchCommand extends Command {
    private ArrayList<Task> displayedTask;

    public void execute() throws InvalidCommandException {
        assert(dataHandler != null);

        SearchEngine searchEngine = new SearchEngine(
                (BasicDataHandler) dataHandler);
        ArrayList<Task> searchList = searchEngine.search(task);
        if (searchList.isEmpty()) {
            throw new InvalidCommandException("Search failed unable to find...");
        } else {
            displayedTask = dataHandler.getDisplayedTasks(task.getStartDate(),
                    task.getEndDate());
            undoHandler.addUndo(this);

        }
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo() This function undo by displaying the previous
     * list.
     */
    @Override
    public void undo() {
        assert(dataHandler != null);
        
        dataHandler.setDisplayedTasks(displayedTask);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        return isCommandValid(parseFlags);
    }

    /**
     * <p>
     * Determine whether the command is valid
     * <p>
     * 
     * @param parseFlags
     *            the set of ParserFlag to be tested
     * @return if it contains more than MIN_VALID_FLAGS flags
     */
    public static boolean isCommandValid(EnumSet<ParserFlags> parseFlags) {
        final EnumSet<ParserFlags> VALID_SEARCH_CATEGORY_PARSE = EnumSet.of(
                ParserFlags.DESCRIPTION_FLAG, ParserFlags.COMMAND_FLAG);
        final EnumSet<ParserFlags> VALID_SEARCH_DATE_PARSE = EnumSet.of(
                ParserFlags.DATE_FLAG, ParserFlags.COMMAND_FLAG);
        final EnumSet<ParserFlags> VALID_SEARCH_PRIORITY_PARSE = EnumSet.of(
                ParserFlags.PRIORITY_FLAG, ParserFlags.COMMAND_FLAG);

        return (ParserFlags.containsOnly(parseFlags,
                VALID_SEARCH_CATEGORY_PARSE)
                || ParserFlags
                        .containsOnly(parseFlags, VALID_SEARCH_DATE_PARSE) || ParserFlags
                    .containsOnly(parseFlags, VALID_SEARCH_PRIORITY_PARSE));
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Search";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of Search should only be <Search> <Description> or <Search> <Date> or <Search> <Priority>";
        return ERROR_MESSAGE;
    }

}

	// End of segment: logic\command\commandList\SearchCommand.java





	/**
	 * origin: logic\command\commandList\UndoCommand.java
	 */

/**
 * TienLong This class makes use of the Command interface to implement execute
 * function for undoCommand
 */
public class UndoCommand extends Command {

    /* (non-Javadoc)
     * @see logic.command.commandList.Command#execute()
     */
    public void execute() throws InvalidCommandException {
        undoHandler.undo();
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() {
        // TODO Auto-generated method stub

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        final EnumSet<ParserFlags> VALID_UNDO_PARSE = EnumSet
                .of(ParserFlags.COMMAND_FLAG);

        return ParserFlags.containsOnly(parseFlags, VALID_UNDO_PARSE);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "Undo";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of undo should only be <Undo>";
        return ERROR_MESSAGE;
    }
}

	// End of segment: logic\command\commandList\UndoCommand.java





	/**
	 * origin: logic\command\commandList\ViewCommand.java
	 */

/**
 * This class makes use of the Command interface to implement execute function
 * for InvalidTask
 */
public class ViewCommand extends Command {

    ArrayList<Task> previousView;

    public void execute() throws InvalidCommandException {
        assert(dataHandler != null);
        
        previousView = dataHandler.getObservableList().getList();
        dataHandler.view(task);
        undoHandler.addUndo(this);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.Command#undo()
     */
    @Override
    public void undo() {
        assert(dataHandler != null);
       
        dataHandler.setDisplayedTasks(previousView);
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#validate(java.util.EnumSet)
     */
    @Override
    public boolean validate(EnumSet<ParserFlags> parseFlags) {
        return isCommandValid(parseFlags);
    }

    /**
     * <p>
     * Determine whether the command is valid
     * <p>
     * 
     * @param parseFlags
     *            the set of ParserFlag to be tested
     * @return if it contains more than MIN_VALID_FLAGS flags
     */
    public static boolean isCommandValid(EnumSet<ParserFlags> parseFlags) {

        final EnumSet<ParserFlags> VALID_VIEW_CATEGORY_PARSE = EnumSet.of(
                ParserFlags.DESCRIPTION_FLAG, ParserFlags.COMMAND_FLAG);
        final EnumSet<ParserFlags> VALID_VIEW_DATE_PARSE = EnumSet.of(
                ParserFlags.DATE_FLAG, ParserFlags.COMMAND_FLAG);
        final EnumSet<ParserFlags> VALID_VIEW_PRIORITY_PARSE = EnumSet.of(
                ParserFlags.PRIORITY_FLAG, ParserFlags.COMMAND_FLAG);

        return (ParserFlags.containsOnly(parseFlags, VALID_VIEW_CATEGORY_PARSE)
                || ParserFlags.containsOnly(parseFlags, VALID_VIEW_DATE_PARSE) || ParserFlags
                    .containsOnly(parseFlags, VALID_VIEW_PRIORITY_PARSE));

    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#toString()
     */
    @Override
    public String toString() {
        final String COMMAND_NAME = "View";
        return COMMAND_NAME;
    }

    /*
     * (non-Javadoc)
     * 
     * @see logic.command.commandList.Command#getValidateErrorMessage()
     */
    @Override
    public String getValidateErrorMessage() {
        final String ERROR_MESSAGE = "Format of view should only be <View> <Date> or <View> <Category> or <View> <Priority>";
        return ERROR_MESSAGE;
    }

}

	// End of segment: logic\command\commandList\ViewCommand.java





	/**
	 * origin: logic\command\UndoHandler.java
	 */

/**
 * UndoHandler stores all undo and redo operation
 */
public class UndoHandler {
    private enum State {
        STATE_UNDO, STATE_ADD_UNDO, STATE_ADD_REDO, STATE_UNDEFINED
    }

    private static UndoHandler undoHandler = new UndoHandler();
    private static Stack<Command> undoStack = new Stack<Command>();
    private static Stack<Command> redoStack = new Stack<Command>();
    private static State currentState = State.STATE_UNDEFINED;

    /**
     * @return the undoHandler instance
     */
    public static UndoHandler getInstance() {
        return undoHandler;
    }

    /**
     * Do not allow user to create new instance
     */
    private UndoHandler() {

    }

    /**
     * Check if there is anything to undo
     * 
     * @return if there is anything to undo
     */
    public static boolean canUndo() {
        return undoStack.size() > 0;
    }

    /**
     * Check if there is anything to redo
     * 
     * @return if there is anything to redo
     */
    public static boolean canRedo() {
        return redoStack.size() > 0;
    }

    /**
     * Precondition : command must not be null, RedoCommand, UndoCommand Add
     * command that can be undo to the undo stack
     * 
     * @param command
     *            the command that could be undo
     * @return Stack<Command> which contains the available commands to undo
     * @throws InvalidCommandException
     *             if command is null, RedoCommand, UndoCommand
     */
    public Stack<Command> addUndo(Command command)
            throws InvalidCommandException {

        final String INVALID_NULL_COMMAND = "command must not be null for addUndo";
        final String INVALID_REDO_COMMAND = "command must not be RedoCommand for addUndo";
        final String INVALID_UNDO_COMMAND = "command must not be UndoCommand for addUndo";

        if (command == null) {
            throw new InvalidCommandException(INVALID_NULL_COMMAND);
        }

        if (command instanceof RedoCommand) {
            throw new InvalidCommandException(INVALID_REDO_COMMAND);
        }

        if (command instanceof UndoCommand) {
            throw new InvalidCommandException(INVALID_UNDO_COMMAND);
        }

        if (!redoStack.isEmpty() && currentState == State.STATE_UNDO) {
            redoStack.clear();
        }

        currentState = State.STATE_ADD_UNDO;
        undoStack.add(command);
        return undoStack;

    }

    /**
     * Undo a command stored at the top of undo stack.
     * 
     * @return Command that was undo
     * @throws InvalidCommandException
     *             if there are no undo command left
     */
    public Command undo() throws InvalidCommandException {

        final String NO_COMMAND_TO_UNDO = "No command to undo";

        if (canUndo()) {
            currentState = State.STATE_UNDO;
            Command command = undoStack.pop();
            redoStack.push(command);
            command.undo();
            return command;

        } else {
            throw new InvalidCommandException(NO_COMMAND_TO_UNDO);
        }

    }

    /**
     * Redo a command at the top of the redo stack.
     * 
     * @return Command that was redo
     * @throws InvalidCommandException
     *             if there are no redo command left
     */
    public Command redo() throws InvalidCommandException {

        final String NO_COMMAND_TO_REDO = "No command to redo";

        if (canRedo()) {
            currentState = State.STATE_ADD_REDO;
            Command command = redoStack.pop();
            command.execute();
            return command;
        } else {
            throw new InvalidCommandException(NO_COMMAND_TO_REDO);
        }
    }
}

	// End of segment: logic\command\UndoHandler.java





	/**
	 * origin: logic\exception\InvalidCommandException.java
	 */

/**
 * Exception for invalid command
 */
@SuppressWarnings("serial")
public class InvalidCommandException extends Exception 
{

        public InvalidCommandException() { super(); }
        public InvalidCommandException(String message) { super(message); }
        public InvalidCommandException(String message, Throwable cause) { super(message, cause); }
        public InvalidCommandException(Throwable cause) { super(cause); }
      
}

	// End of segment: logic\exception\InvalidCommandException.java





	/**
	 * origin: logic\exception\InvalidParseException.java
	 */

/**
 * Exception for Invalid parse
 */
@SuppressWarnings("serial")
public class InvalidParseException extends Exception 
{

        public InvalidParseException() { super(); }
        public InvalidParseException(String message) { super(message); }
        public InvalidParseException(String message, Throwable cause) { super(message, cause); }
        public InvalidParseException(Throwable cause) { super(cause); }
      
}

	// End of segment: logic\exception\InvalidParseException.java





	/**
	 * origin: logic\LogicManager.java
	 */

/**
 *
 */
public class LogicManager {

    private DataHandler dataHandler;
    private CommandExecutor commandExecutor;

    /**
     * Constructor for CommandHandler
     * 
     * @param dataHandler
     *            the handler which contains of all the data
     */
    public LogicManager(DataHandler dataHandler) {
        this.dataHandler = dataHandler;
        this.commandExecutor = new CommandExecutor(this.dataHandler);
    }

    public DynamicParseResult dynamicParse(String userInput) {
        ParserManager parserManager = new ParserManager();
        return parserManager.dynamicParsing(userInput);
    }

    public void setComplete(int index, boolean prevCompleteStatus)
            throws InvalidCommandException {
        String Command;

        if (prevCompleteStatus) {
            Command = "Uncomplete " + index;
        } else {
            Command = "Complete " + index;
        }
        ParseResult parseResult = interpret(Command);
        executeCommand(parseResult);
    }

    /**
     * Interpret what the user had entered
     * @param userInput
     *            the input that the user entered which will be decipher into
     *            task and command
     * @throws InvalidCommandException
     */
    public ParseResult interpret(String userInput) {

        ParserManager parserManager = new ParserManager();
        return parserManager.interpret(userInput);
    }

    /**
     * Execute the command based on parseResult
     * @param parseResult the result parsed
     * @throws InvalidCommandException
     */
    public void executeCommand(ParseResult parseResult)
            throws InvalidCommandException {
        commandExecutor
                .execute(parseResult.getCommand(), parseResult.getTask());
    }

    /**
     * @param index
     *            the index to get the task
     * @return the task at the index or null if it is not valid
     */
    public Task getTaskToBeEdited(int index) {
        if (dataHandler.indexValid(index)) {
            return dataHandler.getTask(index);
        } else {
            return null;
        }
    }
}

	// End of segment: logic\LogicManager.java





	/**
	 * origin: logic\parser\CommandParser.java
	 */

/**
 * Parse the command based on the source
 */
public class CommandParser {

    private Command command;
    private String wordUsed;
    private String wordRemaining;

    /**
     * <p>
     * The source will be parsed to see if it contains date.
     * 
     * @param source
     *            the String to be parsed
     * @return if source contains valid command
     */
    public boolean tryParse(String source) {
        if (source == null) {
            return false;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return false;
        }

        String firstWord = StringHandler.getFirstWord(source);
        String lastWord = StringHandler.getLastWord(source);

        command = getCommand(firstWord);
        if (command != null) {
            wordUsed = firstWord;
            source = handleEditCommandforFirstWord(source);
            setWordRemaining(StringHandler.removeFirstMatched(source, wordUsed));
            return true;
        }

        command = getCommand(lastWord);
        if (command != null) {
            wordUsed = lastWord;
            source = handleEditCommandForLastWord(source);
            setWordRemaining(StringHandler.removeLastMatch(source, wordUsed));
            return true;
        }

        return false;
    }

    /**
     * Remove the index for edit and append it to the front if valid return
     * source if invalid
     * 
     * @param source
     * @return
     */
    private String handleEditCommandforFirstWord(String source) {
        String index = StringHandler.getDigitAfterFirstWord(source);
        if (handleFlexibleEditCommand(source, index)) {
            source = StringHandler.removeDigitAfterFirstWord(source);
            return index + " " + source;

        } else {
            return source;
        }

    }

    /**
     * Remove the index for edit and append it to the front if valid return
     * source if invalid
     * 
     * @param source
     * @return
     */
    private String handleEditCommandForLastWord(String source) {
        String index = StringHandler.getDigitAfterLastWord(source);
        if (handleFlexibleEditCommand(source, index)) {
            source = StringHandler.removeDigitAfterLastWord(source);
            return index + " " + source;
        } else {
            return source;
        }

    }

    /**
     * determine is action needed to be done
     * 
     * @param source
     * @param index
     * @return true if there's a valid index and command is EditCommand
     */
    private boolean handleFlexibleEditCommand(String source, String index) {
        if (command instanceof EditCommand) {
            if (index != null) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }
    }

    /**
     * Get command from the word
     * 
     * @param word
     *            that may contains of the command
     * @return command if valid, null if invalid
     */
    private Command getCommand(String word) {
        return MultiMapMatcher.getMatchedKey(
                KeyWordMappingList.getCommandMultiMap(), word);
    }

    /**
     * Get the command that was parsed
     * 
     * @return command that was parsed
     */
    public Command getCommand() {
        return command;
    }

    /**
     * @return the wordRemaining
     */
    public String getWordRemaining() {
        return wordRemaining;
    }

    /**
     * @param wordRemaining
     *            the wordRemaining to set
     */
    public void setWordRemaining(String wordRemaining) {
        this.wordRemaining = wordRemaining;
    }

    /**
     * @return the wordUsed
     */
    public String getWordUsed() {
        return wordUsed;
    }

    /**
     * @param wordUsed
     *            the wordUsed to set
     */
    public void setWordUsed(String wordUsed) {
        this.wordUsed = wordUsed;
    }
}

	// End of segment: logic\parser\CommandParser.java





	/**
	 * origin: logic\parser\DateParser.java
	 */

/**
 * Parse the date with the help of local date parser and natty parser
 */
public class DateParser {

    private String wordUsed;
    private String wordRemaining;
    private String errorMessage;
    private List<Date> dateList;
    private boolean timeSet;
    private String[] separatedWordRemainings;

    /**
     * <p>
     * The source will be parsed to see if it contains date.
     * 
     * @param source
     *            the String to be parsed
     * @return if source contains valid date
     */
    public boolean tryParse(String source) {

        final String EXCEEDED_DATE_PARSE_LIMIT = "Input contains more than 2 dates to parse";

        if (source == null) {
            return false;
        }

        source = source.trim();

        if (source.isEmpty() || formalDateContainsNegativeNumber(source)
                || formalDateContainsZero(source)) {
            return false;
        }

        source = DateStringMassager.massageData(source);

        Parser nattyParser = new Parser();

        List<DateGroup> dateGroups = nattyParser.parse(source);

        if (dateAvailable(dateGroups)) {
            dateList = getDateList(dateGroups);
            if (exceededDateListLimit()) {
                setErrorMessage(EXCEEDED_DATE_PARSE_LIMIT);
                return false;
            }
            String dateWordUsed = setDateWordUsed(source, dateGroups);

            try {
                dateList = parseDateBeforeEpochYear(dateWordUsed, dateList);
            } catch (ParseException e) {
                return false;
            }

            timeSet = isTimeInferred(dateGroups);
            return true;
        } else {
            return false;
        }
    }

    /**
     * Set the date word used
     * 
     * @param source
     *            the original message
     * @param dateGroups
     *            the group that contains the date info
     * @return
     */
    private String setDateWordUsed(String source, List<DateGroup> dateGroups) {
        String dateWordUsed = getDateWordUsed(source, dateGroups);
        dateWordUsed = DateStringMassager.removeWordDelimiter(dateWordUsed);
        dateWordUsed = DateStringMassager.removeDigitDelimiters(dateWordUsed);

        source = DateStringMassager.removeDigitDelimiters(source);
        source = DateStringMassager.removeWordDelimiter(source);

        String dateConnector = DateStringMassager.getFrontDateConnector(source,
                dateWordUsed);
        wordUsed = dateConnector + dateWordUsed;

        separatedWordRemainings = StringHandler.getSeparatedWord(source,
                wordUsed);
        wordRemaining = StringHandler.removeFirstMatched(source, wordUsed);
        return dateWordUsed;
    }

    /**
     * Check if date limit exceeded
     * 
     * @return if there are more than 2 dates
     */
    private boolean exceededDateListLimit() {
        final int MAX_DATE_PARSE = 2;
        return dateList.size() > MAX_DATE_PARSE;
    }

    /**
     * Check if it contains zero in formal dae
     * 
     * @param source
     *            the original message
     * @return if it contains zero in formal date
     */
    private boolean formalDateContainsZero(String source) {
        String dateWithZeroPattern = ".*\\d\\d\\d\\d/0+/|\\d\\d\\d\\d/\\d+/0+|\\d+/0+/.*";
        return source.matches(dateWithZeroPattern);
    }

    /**
     * Check if it contains negative number in formal date
     * 
     * @param source
     *            the original message
     * @return if it contains negative number in formal date
     */
    private boolean formalDateContainsNegativeNumber(String source) {
        String dateWithNegativePattern = ".*-\\d+/|/-\\d+.*";
        return source.matches(dateWithNegativePattern);
    }

    /**
     * Handles parsing of year before epoch start year (1970), year is parsed by
     * utilizing LocalDateTime parser
     * 
     * @param source
     *            the String which consist of the date to parse
     * @throws ParseException
     *             if source consist of invalid input
     * @return List<Date> which contains all the date information
     */
    private List<Date> parseDateBeforeEpochYear(String source,
            List<Date> dateList) throws ParseException {
        final int INITIAL_INDEX = 0;
        final int EPOCH_START_YEAR = 1970;
        final int yearGroup = 1;
        final int monthGroup = 2;
        final int dayGroup = 3;

        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("u/M/d");
        String yyyymmddRegex = "(\\d\\d\\d\\d)[/-](0?[1-9]|1[012])[/-](3[01]|[012]?[0-9])";

        Pattern pattern = Pattern.compile(yyyymmddRegex);
        Matcher matcher = pattern.matcher(source);
        int dateIndex = INITIAL_INDEX;

        while (matcher.find()) {
            int year = Integer.parseInt(matcher.group(1));
            if (year >= EPOCH_START_YEAR) {
                continue;
            }

            Calendar calendar = convertDateToCalendar(dateList.get(dateIndex));

            LocalDate localDate = LocalDate.parse(
                    matcher.group(yearGroup) + "/" + matcher.group(monthGroup)
                            + "/" + matcher.group(dayGroup), formatter);
            LocalTime localTime = getLocalTime(calendar);
            LocalDateTime localDateTime = LocalDateTime
                    .of(localDate, localTime);

            Date parseResult = convertLocalDateToDate(localDateTime);
            dateList.remove(dateIndex);
            dateList.add(dateIndex, parseResult);
            dateIndex++;

        }

        sortDateList(dateList);

        return dateList;
    }

    /**
     * Convert Calendar timing to LocalTime
     * 
     * @param calendar
     *            the calendar which stores the time
     * @return LocalTime which consist of HH:MM:SS
     */
    private LocalTime getLocalTime(Calendar calendar) {
        return LocalTime.of(calendar.get(Calendar.HOUR_OF_DAY),
                calendar.get(Calendar.MINUTE), calendar.get(Calendar.SECOND),
                calendar.get(Calendar.MILLISECOND));
    }

    /**
     * Convert java.util.date to calendar
     * 
     * @param date
     *            the date to be converted to calendar
     * @return calendar which consist of the date converted
     */
    private Calendar convertDateToCalendar(Date date) {
        Calendar calendar = GregorianCalendar.getInstance();
        calendar.setTime(date);
        return calendar;
    }

    /**
     * Convert local date to date
     * 
     * @param localDate
     *            the local date to be converted to date
     * @return the date inside local date
     */
    private Date convertLocalDateToDate(LocalDateTime localDate) {
        return Date.from(localDate.atZone(ZoneId.systemDefault()).toInstant());
    }

    /**
     * Get number of dates
     * 
     * @return number of dates
     */
    public int getNumberOfDates() {
        return dateList.size();
    }

    /**
     * Determines if time is set
     * 
     * @return is time set
     */
    public boolean isTimeSet() {
        return timeSet;
    }

    /**
     * @return the start date
     */
    public LocalDate getStartDate() {
        final int START_DATE_INDEX = 0;
        return dateToLocalDate(dateList.get(START_DATE_INDEX));
    }

    /**
     * @return get end date
     */
    public LocalDate getEndDate() {
        final int LIST_OFFSET = 1;
        final int END_DATE_INDEX = dateList.size() - LIST_OFFSET;
        final int START_DATE_INDEX = 0;

        if (END_DATE_INDEX == START_DATE_INDEX) {
            return getStartDate();

        } else {
            return dateToLocalDate(dateList.get(END_DATE_INDEX));
        }
    }

    /**
     * @return start time
     */
    public LocalTime getStartTime() {
        final int START_TIME_INDEX = 0;

        if (timeSet) {
            return dateToLocalTime(dateList.get(START_TIME_INDEX));
        } else {
            return Task.TIME_NOT_SET;
        }

    }

    /**
     * @return end time
     */
    public LocalTime getEndTime() {
        final int END_TIME_INDEX = dateList.size() - 1;
        final int START_TIME_INDEX = 0;

        if (END_TIME_INDEX == START_TIME_INDEX) {
            return getStartTime();
        }

        if (timeSet) {
            return dateToLocalTime(dateList.get(END_TIME_INDEX));
        } else {
            return Task.TIME_NOT_SET;
        }
    }

    /**
     * @param dateGroup
     *            the group which contains the date list
     * @return the date list
     */
    private List<Date> getDateList(List<DateGroup> dateGroup) {

        final int START_INDEX = 0;
        List<Date> dateList = dateGroup.get(START_INDEX).getDates();
        sortDateList(dateList);
        return dateList;
    }

    /**
     * Sort the date list based on which start first.
     * 
     * @param dateList
     *            the list to be sorted
     */
    private void sortDateList(List<Date> dateList) {
        Collections.sort(dateList);
    }

    /**
     * Check if date is available
     * 
     * @param dateGroups
     *            the date group which contains the date
     * @return is date available
     */
    private boolean dateAvailable(List<DateGroup> dateGroups) {
        final int NOT_AVAILABLE = 0;
        return dateGroups.size() > NOT_AVAILABLE;
    }

    /**
     * @param dateGroups
     *            the date group which contains the date
     * @return is time inferred
     */
    private boolean isTimeInferred(List<DateGroup> dateGroups) {
        final int INITIAL_GROUP = 0;
        return !dateGroups.get(INITIAL_GROUP).isTimeInferred();
    }

    /**
     * Get the date word used for parsing
     * 
     * @param source
     *            the original message
     * @param dateGroups
     *            the date group which contains the date
     * @return the date word used
     */
    private String getDateWordUsed(String source, List<DateGroup> dateGroups) {
        int startPosition = source.length();
        int endPosition = 0;
        for (DateGroup dateGroup : dateGroups) {
            int position = dateGroup.getPosition();
            int length = dateGroup.getText().length();
            startPosition = Math.min(startPosition, position);
            endPosition = Math.max(position + length, endPosition);
        }

        String dateText = source.substring(startPosition, endPosition);

        return dateText;
    }

    /**
     * @param date
     *            to be converted
     * @return localdate converted from date
     */
    private LocalDate dateToLocalDate(Date date) {
        Instant instant = Instant.ofEpochMilli(date.getTime());
        return LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
                .toLocalDate();
    }

    /**
     * @param time
     *            the time to be converted
     * @return localtime converted from time
     */
    private LocalTime dateToLocalTime(Date time) {
        Instant instant = Instant.ofEpochMilli(time.getTime());
        return LocalDateTime.ofInstant(instant, ZoneId.systemDefault())
                .toLocalTime();
    }

    /**
     * @return the wordUsed
     */
    public String getWordUsed() {
        return wordUsed;
    }

    /**
     * @param wordUsed
     *            the wordUsed to set
     */
    public void setWordUsed(String wordUsed) {
        this.wordUsed = wordUsed;
    }

    /**
     * @return the wordRemaining
     */
    public String getWordRemaining() {
        return wordRemaining;
    }

    /**
     * @return the warningMessage
     */
    public String getErrorMessage() {
        return errorMessage;
    }

    /**
     * @param warningMessage
     *            the warningMessage to set
     */
    public void setErrorMessage(String warningMessage) {
        this.errorMessage = warningMessage;
    }

    /**
     * @return the separatedWordRemainings
     */
    public String[] getSeparatedWordRemainings() {
        return separatedWordRemainings;
    }

    /**
     * @param separatedWordRemainings
     *            the separatedWordRemainings to set
     */
    public void setSeparatedWordRemainings(String[] separatedWordRemainings) {
        this.separatedWordRemainings = separatedWordRemainings;
    }

}

	// End of segment: logic\parser\DateParser.java





	/**
	 * origin: logic\parser\DateStringMassager.java
	 */

/**
 *
 */
public class DateStringMassager {

    private static final String START_DIGIT_DELIMITER = "{[";
    private static final String END_DIGIT_DELIMITER = "]}";
    private static final String WORD_DELIMITER = ".";

    public static String massageData(String source) {

        source = convertImplicitFormalDate(source);
        source = convertFormalDate(source);
        source = replaceNonDateDigitWithDelimiter(source);
        source = replaceDescriptionWithDelimiter(source);
        source = MultiMapMatcher.replaceMatchedWithKey(
                createFakeMultiMapForShortForm(), source);
        source = addDelimiterForIndexSelection(source);
        source = addDelimiterForInvalidFormalDate(source);
        source = replaceWordWithDelimiter(source);
        return source;
    }

    /**
     * Add delimiter if it is an index
     * 
     * @param source
     *            the original message
     * @return source with delimiter added for index
     */
    private static String addDelimiterForIndexSelection(String source) {
        final int COMMAND_GRPOUP = 1;
        final int INDEX_GROUP = 2;
        final int SPACING_GROUP = 3;

        String editKeyWordsRegex = getEditKeyWordsRegex();

        String indexPattern = "(?i)(^\\s*(?:" + editKeyWordsRegex
                + ")\\s+)(\\d+)(\\s+|\\$)";
        Pattern pattern = Pattern.compile(indexPattern);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(result, matcher.group(COMMAND_GRPOUP)
                    + START_DIGIT_DELIMITER + matcher.group(INDEX_GROUP)
                    + END_DIGIT_DELIMITER + matcher.group(SPACING_GROUP));
        }

        matcher.appendTail(result);

        return result.toString();

    }

    /**
     * Get the edit key word regex
     * 
     * @return editKeyWords
     */
    private static String getEditKeyWordsRegex() {
        String editKeyWordsRegex = "";
        ImmutableMap<Command, Collection<String>> editKeyWords = KeyWordMappingList
                .getEditCommandMap();
        for (Command key : editKeyWords.keySet()) {
            for (String keyWord : editKeyWords.get(key)) {
                editKeyWordsRegex += (keyWord + "|");

            }
        }
        assert (editKeyWordsRegex != null);
        assert (editKeyWordsRegex.length() > 0);
        editKeyWordsRegex = editKeyWordsRegex.substring(0,
                editKeyWordsRegex.length() - 1);
        return editKeyWordsRegex;
    }

    /**
     * @param source
     *            the String that will be searched
     * @param dateWordUsed
     *            the words used for parsing the date
     * @return the frontDateConnector word ("by","at","from" etc) or "" if there
     *         is no dateConnector word
     */
    public static String getFrontDateConnector(String source,
            String dateWordUsed) {

        final int WORD_GROUP = 1;
        String frontDateConnectorPattern = "(\\w+\\s+)(?="
                + Pattern.quote(dateWordUsed) + ")";
        Pattern pattern = Pattern.compile(frontDateConnectorPattern);
        Matcher matcher = pattern.matcher(source);

        if (matcher.find()) {
            String possibleWord = matcher.group(WORD_GROUP);

            if (matchAvailableDateConnector(possibleWord)) {
                return possibleWord;
            } else {
                return "";
            }
        } else {
            return "";
        }
    }

    /**
     * Check if source contains date connector
     * 
     * @param source
     *            the original message
     * @return if it contains date connector
     */
    private static boolean matchAvailableDateConnector(String source) {
        String dateConnectorPattern = "(?i)^in |^on |^from |^at |^by |^date ";
        Pattern pattern = Pattern.compile(dateConnectorPattern);
        Matcher matcher = pattern.matcher(source);

        return matcher.find();

    }

    /**
     * Add delimiter for digits that are not date
     * 
     * @param source
     *            the original message
     * @return source with delimiter added for digit which are not dates
     */
    private static String replaceNonDateDigitWithDelimiter(String source) {
        source = replaceAllDigitsWithDelimiter(source);
        source = replaceWordDigitAtEndWithDelimiter(source);
        source = removeDelimiterForDateDigitByWord(source);
        source = removeDelimiterForDateDigitByNextWord(source);
        source = removeDelimiterForDateDigitByPreviousWord(source);
        return source;
    }

    /**
     * Add delimiter for digit at end of word if it is not date
     * 
     * @param source
     *            the original message
     * @return source with delimiter added for non-date digit at the end of word
     */
    private static String replaceWordDigitAtEndWithDelimiter(String source) {
        final String endOfWordDigitPattern = "(?<=[A-z])(\\d+)(?=\\s)";
        final int DIGIT_GROUP = 1;
        Pattern pattern = Pattern.compile(endOfWordDigitPattern);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(result,
                    START_DIGIT_DELIMITER + matcher.group(DIGIT_GROUP)
                            + END_DIGIT_DELIMITER);
        }

        return matcher.appendTail(result).toString();
    }

    /**
     * Remove delimiter for date digit if previous word is a date
     * 
     * @param source
     *            the original message
     * @return source with delimiter removed for digit if the previous word is
     *         date
     */
    private static String removeDelimiterForDateDigitByPreviousWord(
            String source) {
        final String previousWordWithDigitPattern = "(\\w+\\s+)(\\{\\[\\d+\\]\\})";
        final int WORD_GROUP = 1;
        final int DIGIT_GROUP = 2;
        Pattern pattern = Pattern.compile(previousWordWithDigitPattern);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            String digit = matcher.group(DIGIT_GROUP);
            String word = matcher.group(WORD_GROUP);

            if (containsDateFormat(matcher.group(WORD_GROUP).trim())) {
                digit = removeDigitDelimiters(digit);
            }
            matcher.appendReplacement(result, word + digit);
        }

        return matcher.appendTail(result).toString();
    }

    /**
     * Remove all delimiter
     * 
     * @param source
     *            the original message
     * @return source with all delimiter removed
     */
    public static String removeDigitDelimiters(String source) {
        source = StringHandler.removeAll(source,
                Pattern.quote(START_DIGIT_DELIMITER));
        source = StringHandler.removeAll(source,
                Pattern.quote(END_DIGIT_DELIMITER));
        return source;
    }

    /**
     * Remove delimiter for date digit if it is a date
     * 
     * @param source
     *            the original message
     * @return source with delimiter removed for digit if it is a date
     */
    private static String removeDelimiterForDateDigitByWord(String source) {
        final String digitFollowedByWordRegex = "(\\{\\[\\d+\\]\\})(\\w+)(?=$|\\s)";
        final int DIGIT_GROUP = 1;
        final int WORD_GROUP = 2;
        Pattern pattern = Pattern.compile(digitFollowedByWordRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            String digit = matcher.group(DIGIT_GROUP);
            String word = matcher.group(WORD_GROUP);

            if (containsDateFormat(matcher.group(WORD_GROUP).trim())) {
                digit = removeDigitDelimiters(digit);
            }
            matcher.appendReplacement(result, digit + word);
        }

        return matcher.appendTail(result).toString();
    }

    /**
     * Remove delimiter for date digit if next word is a date
     * 
     * @param source
     *            the original message
     * @return source with delimiter removed for digit if the next word is date
     */
    private static String removeDelimiterForDateDigitByNextWord(String source) {
        final String digitWithNextWord = "(?<=\\s|^)(\\{\\[\\d+\\]\\})(\\s+\\w+|$)";
        final int DIGIT_GROUP = 1;
        final int WORD_GROUP = 2;
        Pattern pattern = Pattern.compile(digitWithNextWord);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            String digit = matcher.group(DIGIT_GROUP);
            String word = matcher.group(WORD_GROUP);

            if (containsDateFormat(matcher.group(WORD_GROUP).trim())) {
                digit = removeDigitDelimiters(digit);
            }
            matcher.appendReplacement(result, digit + word);
        }

        return matcher.appendTail(result).toString();
    }

    /**
     * add delimiter if the word is a description and not a date
     * 
     * @param source
     *            the original message
     * @return add delimiter if the word is a description and not a date
     */
    private static String replaceDescriptionWithDelimiter(String source) {

        final String[] POSSIBLE_DATE_DESCRIPTION = { "day", "days", "week",
                "weeks", "month", "months", "year", "years", "xmas", "christmas", "summer", "spring", "winter", "autumn" };
        String restrictedWordRegex = addRestrictedWordToRegex(POSSIBLE_DATE_DESCRIPTION);

        String regex = "(?i)(?<!\\d)\\s+(" + restrictedWordRegex
                + ")($|\\s+\\w+)($|\\s+\\w+){0,1}";

        final int POSSIBLE_DATE_GROUP = 1;
        final int NEXT_WORD_GROUP = 2;
        final int NEXT_NEXT_WORD_GROUP = 3;

        Pattern pattern = Pattern.compile(regex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            if (isDateDescription(matcher.group(POSSIBLE_DATE_GROUP),
                    matcher.group(NEXT_WORD_GROUP),
                    matcher.group(NEXT_NEXT_WORD_GROUP))) {
                matcher.appendReplacement(result, " " + START_DIGIT_DELIMITER
                        + matcher.group(POSSIBLE_DATE_GROUP)
                        + END_DIGIT_DELIMITER + matcher.group(NEXT_WORD_GROUP)
                        + matcher.group(NEXT_NEXT_WORD_GROUP));
            } else {
                matcher.appendReplacement(
                        result,
                        " " + matcher.group(POSSIBLE_DATE_GROUP)
                                + matcher.group(NEXT_WORD_GROUP)
                                + matcher.group(NEXT_NEXT_WORD_GROUP));
            }

        }

        return matcher.appendTail(result).toString();

    }

    /**
     * Check if the description is a date
     * 
     * @param possibleDateDescription
     *            that could be describing date
     * @param nextWord
     * @param nextNextWord
     * @return isDateDescription
     */
    private static boolean isDateDescription(String possibleDateDescription,
            String nextWord, String nextNextWord) {

        if (isEndOfString(nextWord)) {
            return false;
        } else if (isDate(nextWord) || isPriority(nextWord + nextNextWord)) {
            return false;
        } else if (isIntermediateDateConnector(nextWord)
                && (!isEndOfString(nextNextWord)) && isDate(nextNextWord)) {
            return false;
        } else {
            return true;
        }
    }

    /**
     * Check if it is priority
     * 
     * @param string
     *            the source
     * @return isPriority
     */
    private static boolean isPriority(String source) {
        PriorityParser priorityParser = new PriorityParser();
        return priorityParser.tryParse(source);
    }

    /**
     * Check if it is date connector
     * 
     * @param nextWord
     * @return isIntermediateDateConnector
     */
    private static boolean isIntermediateDateConnector(String nextWord) {
        final String[] POSSIBLE_INTERMEDIATE_CONNECTOR = { "after", "before",
                "to" };
        return StringHandler.containsWord(nextWord.trim(),
                POSSIBLE_INTERMEDIATE_CONNECTOR);
    }

    /**
     * Check if nextWord is date
     * 
     * @param nextWord
     * @return is nextWord date
     */
    private static boolean isDate(String nextWord) {
        DateParser dateParser = new DateParser();
        return dateParser.tryParse(nextWord);
    }

    /**
     * @param nextWord
     * @return is nextWord end of String
     */
    private static boolean isEndOfString(String nextWord) {
        return nextWord == null || nextWord.trim().isEmpty();
    }

    /**
     * add restricted word to regex
     * 
     * @param RESTRICTED_DATE
     * @return restrictedWordRegex
     */
    private static String addRestrictedWordToRegex(
            final String[] RESTRICTED_DATE) {

        String restrictedWordRegex = "";
        for (String word : RESTRICTED_DATE) {
            restrictedWordRegex += (word + "|");
        }

        assert (restrictedWordRegex != null);
        assert (restrictedWordRegex.length() > 0);
        restrictedWordRegex = restrictedWordRegex.substring(0,
                restrictedWordRegex.length() - 1);
        return restrictedWordRegex;
    }

    /**
     * Add delimiters for all digit
     * 
     * @param source
     *            the original message
     * @return source with delimiter added for all digit
     */
    private static String replaceAllDigitsWithDelimiter(String source) {

        final String numRegex = "((?<!/\\d{0,4}|:\\d{0,2})-*\\d+(?=$|\\s|a|p|z|,|-|\\Q.\\E))";

        final int digitGroup = 1;

        Pattern pattern = Pattern.compile(numRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(result,
                    START_DIGIT_DELIMITER + matcher.group(digitGroup)
                            + END_DIGIT_DELIMITER);
        }

        return matcher.appendTail(result).toString();

    }

    /**
     * Add delimiter for word
     * 
     * @param source
     *            the original message
     * @return source with delimiter added for word
     */
    private static String replaceWordWithDelimiter(String source) {
        final String numRegex = "([A-z" + Pattern.quote(WORD_DELIMITER)
                + "]+(?=\\s))";

        final int WORD_GROUP = 1;

        Pattern pattern = Pattern.compile(numRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(result, matcher.group(WORD_GROUP)
                    + WORD_DELIMITER);
        }

        return matcher.appendTail(result).toString().trim();

    }

    /**
     * Remove word delimiter
     * 
     * @param source
     *            the original message
     * @return source with word delimiter removed
     */
    public static String removeWordDelimiter(String source) {
        return StringHandler.removeAll(source, Pattern.quote(WORD_DELIMITER)
                + "(?=\\s|$)");
    }

    /**
     * Check if it contains date format
     * 
     * @param source
     *            the original message
     * @return if it contains date format
     */
    private static boolean containsDateFormat(String source) {
        DateFormatSymbols dateFormat = new DateFormatSymbols();
        String[] shortWeekdays = dateFormat.getShortWeekdays();
        String[] longWeekdays = dateFormat.getWeekdays();
        String[] shortMonths = dateFormat.getShortMonths();
        String[] longMonths = dateFormat.getMonths();
        String[] timeUnit = { "hour", "hours", "hr", "hrs", "minute", "min",
                "second", "sec", "am", "pm" };
        String[] commonDateShortForm = { "sept", "day", "days", "week",
                "weeks", "month", "months", "year", "years", "today",
                "tomorrow" };
        // today, tomorrow

        if (StringHandler.containsWord(source, shortWeekdays, longWeekdays,
                shortMonths, longMonths, timeUnit, commonDateShortForm)) {
            return true;
        } else {
            return false;
        }

    }

    /**
     * @param source
     *            which may consist of DD/MM/YYYY format
     * @return replaced string with YYYY/MM/DD format
     */
    private static String convertFormalDate(String source) {
        final int yearGroup = 3;
        final int monthGroup = 2;
        final int dayGroup = 1;
        final String ddmmyyyyRegex = "(?<!\\d)([012]?[0-9]|3[01])[/](0?[1-9]|1[012])[/](\\d+)";

        Pattern pattern = Pattern.compile(ddmmyyyyRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(result, matcher.group(yearGroup) + "/"
                    + matcher.group(monthGroup) + "/" + matcher.group(dayGroup));
        }
        matcher.appendTail(result);

        return result.toString();

    }

    /**
     * @param source
     *            the original message
     * @return the converted date
     */
    private static String convertImplicitFormalDate(String source) {
        source = convertDateDDMM(source);
        source = convertDateDDMMYY(source);
        return source;
    }

    /**
     * This function convert date in DD/MM/YY format to DD/MM/20YY format
     * 
     * @param source
     *            which consist of DD/MM/YY format
     * @return replaced string with DD/MM/20YY format
     */
    private static String convertDateDDMMYY(String source) {
        final int inferredYear = 20;

        final int startGroup = 1;
        final int dayGroup = 2;
        final int monthGroup = 3;
        final int yearGroup = 4;
        final int endGroup = 5;

        final String ddmmyyRegex = "([^\\w]|^)+(\\d{1,2})[/](\\d{1,2})[/](\\d\\d)([^\\w]|$)+";

        Pattern pattern = Pattern.compile(ddmmyyRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(
                    result,
                    matcher.group(startGroup) + matcher.group(dayGroup) + "/"
                            + matcher.group(monthGroup) + "/" + inferredYear
                            + matcher.group(yearGroup)
                            + matcher.group(endGroup));
        }

        matcher.appendTail(result);
        return result.toString();
    }

    /**
     * This function convert date in DD/MM format to DD/MM/YYYY format
     * 
     * @param source
     *            which consist of DD/MM format
     * @return replaced string with DD/MM/YYYY format
     */
    private static String convertDateDDMM(String source) {
        final int inferredYear = LocalDateTime.now().getYear();
        final int startGroup = 1;
        final int dayGroup = 2;
        final int monthGroup = 3;
        final int endGroup = 4;

        final String ddmmyyRegex = "(\\s+|^)+(\\d{1,2})[/](\\d{1,2})(\\s+|$)";

        Pattern pattern = Pattern.compile(ddmmyyRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find() && !matcher.group(endGroup).matches("/|-")) {
            matcher.appendReplacement(result, matcher.group(startGroup)
                    + matcher.group(dayGroup) + "/" + matcher.group(monthGroup)
                    + "/" + inferredYear + matcher.group(endGroup));
        }

        matcher.appendTail(result);
        return result.toString();

    }

    /**
     * This function create the short form that will be replace This is a temp
     * solution as the real data will be from a file.
     * 
     * @return
     */
    private static Multimap<String, String> createFakeMultiMapForShortForm() {

        Multimap<String, String> mappedWords = ArrayListMultimap.create();
        String tomorrow = "tomorrow";

        final Map<String, Collection<String>> tommorrowMap = ImmutableMap
                .<String, Collection<String>> of(tomorrow,
                        Arrays.asList("tml", "tmr", "nxt day"));

        for (String key : tommorrowMap.keySet()) {
            mappedWords.putAll(key, tommorrowMap.get(key));
        }

        return mappedWords;

    }

    /**
     * add delimiter for invalid formal date
     * 
     * @param source
     *            the original message
     * @return delimiter added for invalid formal date
     */
    private static String addDelimiterForInvalidFormalDate(String source) {
        source = addDelimiterForInvalidDateRange(source);
        source = addDelimiterForInvalidDate(source);
        return source;
    }

    /**
     * add delimiter for invalid date
     * 
     * @param source
     *            the original message
     * @return delimiter added for invalid date
     */
    private static String addDelimiterForInvalidDate(String source) {

        final int FORMAL_DATE_GROUP = 1;
        final String DATE_SEPARATOR = "/";
        final int MAX_SEPARATOR = 3;
        final int STRING_OFFSET = 1;

        String formalDatePattern = "((?:\\d+/)+\\d*)";

        Pattern pattern = Pattern.compile(formalDatePattern);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            String matchedString = matcher.group(FORMAL_DATE_GROUP);
            String lastChar = matchedString.substring(matchedString.length()
                    - STRING_OFFSET);
            String[] digitFromFormalDate = matchedString.split(DATE_SEPARATOR);

            if (lastChar.equals(DATE_SEPARATOR)
                    || digitFromFormalDate.length > MAX_SEPARATOR
                    || containsInvalidFormalDateDigit(digitFromFormalDate)) {
                matcher.appendReplacement(result, START_DIGIT_DELIMITER
                        + matchedString + END_DIGIT_DELIMITER);
            } else {
                matcher.appendReplacement(result, matchedString);
            }
        }

        return matcher.appendTail(result).toString();

    }

    /**
     * check if it contains invalid formal date in the digit
     * 
     * @param digitFromFormalDate
     *            the digits from formal date
     * @return if it contains invalid formal date in the digit
     */
    private static boolean containsInvalidFormalDateDigit(
            String[] digitFromFormalDate) {
        final int INVALID_DATE_DIGIT = 3;
        final int MAX_DATE_DIGIT = 4;

        for (String digit : digitFromFormalDate) {
            return (digit.length() == INVALID_DATE_DIGIT || digit.length() > MAX_DATE_DIGIT);
        }

        return false;
    }

    /**
     * Add delimiter for invalid date range
     * 
     * @param source
     *            the original message
     * @return source with delimiter added for invalid date range
     */
    @SuppressWarnings("finally")
    private static String addDelimiterForInvalidDateRange(String source) {
        final int YEAR_GROUP = 1;
        final int FIRST_DATE_SEPARATOR = 2;
        final int MONTH_GROUP = 3;
        final int SECOND_DATE_SEPARATOR = 4;
        final int DAY_GROUP = 5;
        boolean formalDateInvalid = false;
        String yyyymmddRegex = "(\\d+)(/)(\\d+)(/)(\\d+)";

        Pattern pattern = Pattern.compile(yyyymmddRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            try {
                matcher.appendReplacement(
                        result,
                        START_DIGIT_DELIMITER + matcher.group(YEAR_GROUP)
                                + matcher.group(FIRST_DATE_SEPARATOR)
                                + matcher.group(MONTH_GROUP)
                                + matcher.group(SECOND_DATE_SEPARATOR)
                                + matcher.group(DAY_GROUP)
                                + END_DIGIT_DELIMITER);
                int year = Integer.parseInt(matcher.group(YEAR_GROUP));
                int month = Integer.parseInt(matcher.group(MONTH_GROUP));
                int day = Integer.parseInt(matcher.group(DAY_GROUP));
                formalDateInvalid = isDateInvalid(year, month, day);

            } catch (NumberFormatException numberTooBig) {
                formalDateInvalid = true;
            } finally {
                if (formalDateInvalid) {
                    matcher.appendTail(result);
                    return result.toString();

                } else {
                    return source;
                }
            }
        }
        return source;
    }

    /**
     * @param year
     * @param month
     * @param day
     * @return is date invalid
     */
    private static boolean isDateInvalid(int year, int month, int day) {
        boolean invalidYear = isYearInvalid(year);
        boolean invalidMonth = isMonthInvalid(month);
        boolean isDayInvalid = isDayInvalid(day, month, year);
        return invalidYear || invalidMonth || isDayInvalid;
    }

    /**
     * @param year
     * @return is year invalid
     */
    private static boolean isYearInvalid(int year) {
        return yearContains3Digit(year) || yearContainsMoreThan4Digit(year);
    }

    /**
     * @param year
     * @return if year contains 3 digit
     */
    private static boolean yearContains3Digit(int year) {
        final int digitCheck = 3;
        return ((Integer) year).toString().length() == digitCheck;

    }

    /**
     * @param day
     * @param month
     * @param year
     * @return invalid day
     */
    private static boolean isDayInvalid(int day, int month, int year) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("y/M/d");
        final String DATE_SEPARATOR = "/";
        year = setValidYearToTest(year);

        String date = year + DATE_SEPARATOR + month + DATE_SEPARATOR + day;

        try {
            LocalDate parsedDate = LocalDate.parse(date, formatter);
            return (parsedDate.getDayOfMonth() != day);

        } catch (DateTimeParseException pe) {
            return true;
        }

    }

    /**
     * @param year
     * @return 1 if year is invalid, year if valid
     */
    private static int setValidYearToTest(int year) {
        final int INVALID_YEAR = 0;
        final int VALID_YEAR = 1;

        if (year == INVALID_YEAR) {
            year = VALID_YEAR;
        }

        return year;
    }

    /**
     * @param month
     * @return is month invalid
     */
    private static boolean isMonthInvalid(int month) {
        final int MAX_MONTH = 12;
        return month > MAX_MONTH;
    }

    /**
     * @param year
     * @return if year contains more than 4 digit
     */
    private static boolean yearContainsMoreThan4Digit(int year) {
        final int DIGIT_LIMIT = 4;
        return ((Integer) year).toString().length() > DIGIT_LIMIT;

    }

}

	// End of segment: logic\parser\DateStringMassager.java





	/**
	 * origin: logic\parser\DescriptionParser.java
	 */

/**
 *
 */
public class DescriptionParser {
    private String wordUsed;
    private String wordRemaining;
    private String description;

    /**
     * <p>
     * The source will be parsed to see if it contains date.
     * 
     * @param source
     *            the String to be parsed
     * @return if source contains valid description
     */
    public boolean tryParse(String source) {
        if (source == null) {
            return false;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return false;
        }

        wordUsed = description = source;
        wordRemaining = "";

        return true;
    }

    /**
     * @param separatedWordsRemaining
     * @param commandWordUsed
     * @return is description separated
     */
    public boolean isDescriptionSeparated(String[] separatedWordsRemaining,
            String commandWordUsed) {
        final int SEPARTED_LENGTH = 3;
        final int NOT_SEPARATED = 1;
        if (separatedWordsRemaining == null || commandWordUsed == null || separatedWordsRemaining.length == NOT_SEPARATED) {
            return false; 
        }

        if (separatedWordsRemaining.length >= SEPARTED_LENGTH) {
            return true;
        }

        for (String word : separatedWordsRemaining) {
            String removedWord = StringHandler.removeFirstMatchedWord(word,
                    commandWordUsed);
            removedWord = removedWord.trim();
            word = word.trim();
            if (!(removedWord.equals(word)) && consistWord(removedWord)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Check if there are still words
     * 
     * @param source
     *            the string to check
     * @return if there are still words
     */
    private boolean consistWord(String source) {
        return !(source.trim().isEmpty());
    }

    /**
     * @return the wordUsed
     */
    public String getWordRemaining() {
        return wordRemaining;
    }

    /**
     * @return the wordRemaining
     */
    public String getWordUsed() {
        return wordUsed;
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * @param description
     *            the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

}

	// End of segment: logic\parser\DescriptionParser.java





	/**
	 * origin: logic\parser\DynamicParseResult.java
	 */

/**
 *
 */
public class DynamicParseResult {
    private Command command;
    private Task task;
    private EnumSet<ParserFlags> parseFlags;

    private String dateWordUsed;
    private String priorityWordUsed;
    private String commandWordUsed;
    private String descriptionWordUsed;

    /**
     * @return the command
     */
    public Command getCommand() {
        return command;
    }

    /**
     * @param command
     *            the command to set
     */
    public void setCommand(Command command) {
        this.command = command;
    }

    /**
     * @return the task
     */
    public Task getTask() {
        return task;
    }

    /**
     * @param task
     *            the task to set
     */
    public void setTask(Task task) {
        this.task = task;
    }

    /**
     * @return the dateWordUsed
     */
    public String getDateWordUsed() {
        return dateWordUsed;
    }

    /**
     * @param dateWordUsed
     *            the dateWordUsed to set
     */
    public void setDateWordUsed(String dateWordUsed) {
        this.dateWordUsed = dateWordUsed;
    }

    /**
     * @return the priorityWordUsed
     */
    public String getPriorityWordUsed() {
        return priorityWordUsed;
    }

    /**
     * @param priorityWordUsed
     *            the priorityWordUsed to set
     */
    public void setPriorityWordUsed(String priorityWordUsed) {
        this.priorityWordUsed = priorityWordUsed;
    }

    /**
     * @return the commandWordUsed
     */
    public String getCommandWordUsed() {
        return commandWordUsed;
    }

    /**
     * @param commandWordUsed
     *            the commandWordUsed to set
     */
    public void setCommandWordUsed(String commandWordUsed) {
        this.commandWordUsed = commandWordUsed;
    }

    /**
     * @return the descriptionWordUsed
     */
    public String getDescriptionWordUsed() {
        return descriptionWordUsed;
    }

    /**
     * @param descriptionWordUsed
     *            the descriptionWordUsed to set
     */
    public void setDescriptionWordUsed(String descriptionWordUsed) {
        this.descriptionWordUsed = descriptionWordUsed;
    }

    /**
     * @return the parseFlags
     */
    public EnumSet<ParserFlags> getParseFlags() {
        return parseFlags;
    }

    /**
     * @param parseFlags
     *            the parseFlags to set
     */
    public void setParseFlags(EnumSet<ParserFlags> parseFlags) {
        this.parseFlags = parseFlags;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return "DynamicParseResult [command=" + command + ", task=" + task
                + ", parseFlags=" + parseFlags + ", dateWordUsed="
                + dateWordUsed + ", priorityWordUsed=" + priorityWordUsed
                + ", commandWordUsed=" + commandWordUsed
                + ", descriptionWordUsed=" + descriptionWordUsed + "]";
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        DynamicParseResult other = (DynamicParseResult) obj;
        if (command == null) {
            if (other.command != null)
                return false;
        } else if (!command.equals(other.command))
            return false;
        if (commandWordUsed == null) {
            if (other.commandWordUsed != null)
                return false;
        } else if (!commandWordUsed.equals(other.commandWordUsed))
            return false;
        if (dateWordUsed == null) {
            if (other.dateWordUsed != null)
                return false;
        } else if (!dateWordUsed.equals(other.dateWordUsed))
            return false;
        if (descriptionWordUsed == null) {
            if (other.descriptionWordUsed != null)
                return false;
        } else if (!descriptionWordUsed.equals(other.descriptionWordUsed))
            return false;
        if (parseFlags == null) {
            if (other.parseFlags != null)
                return false;
        } else if (!parseFlags.equals(other.parseFlags))
            return false;
        if (priorityWordUsed == null) {
            if (other.priorityWordUsed != null)
                return false;
        } else if (!priorityWordUsed.equals(other.priorityWordUsed))
            return false;
        if (task == null) {
            if (other.task != null)
                return false;
        } else if (!task.equals(other.task))
            return false;
        return true;
    }

}

	// End of segment: logic\parser\DynamicParseResult.java





	/**
	 * origin: logic\parser\ParseResult.java
	 */

/**
 *
 */
public class ParseResult {
    private Task task;
    private Command command;
    private boolean isSuccessful;
    private String failedMessage;

    /**
     * 
     */
    public ParseResult() {
    }

    /**
     * @param task
     * @param command
     */
    public ParseResult(Command command, Task task) {
        this.command = command;
        this.task = task;
    }

    /**
     * @return the task
     */
    public Task getTask() {
        return task;
    }

    /**
     * @param task
     *            the task to set
     */
    public void setTask(Task task) {
        this.task = task;
    }

    /**
     * @return the command
     */
    public Command getCommand() {
        return command;
    }

    /**
     * @param command
     *            the command to set
     */
    public void setCommand(Command command) {
        this.command = command;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        ParseResult other = (ParseResult) obj;
        if (command == null) {
            if (other.command != null)
                return false;
        } else if (!command.equals(other.command))
            return false;
        if (task == null) {
            if (other.task != null)
                return false;
        } else if (!task.equals(other.task))
            return false;
        return true;
    }

    /**
     * @return the isSuccessful
     */
    public boolean isSuccessful() {
        return isSuccessful;
    }

    /**
     * @param isSuccessful
     *            the isSuccessful to set
     */
    public void setSuccessful(boolean isSuccessful) {
        this.isSuccessful = isSuccessful;
    }

    /**
     * @return the failedMessage
     */
    public String getFailedMessage() {
        return failedMessage;
    }

    /**
     * @param failedMessage
     *            the failedMessage to set
     */
    public void setFailedMessage(String failedMessage) {
        this.failedMessage = failedMessage;
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return "ParseResult [command =" + command + ", task=" + task + "]";
    }

}

	// End of segment: logic\parser\ParseResult.java





	/**
	 * origin: logic\parser\ParserFlags.java
	 */

/**
 * <p>
 * ParserFlag keep track of parses that are executed successfully.
 * <p>
 */
public enum ParserFlags {
    DATE_FLAG, PRIORITY_FLAG, DESCRIPTION_FLAG, COMMAND_FLAG;

    /**
     * Compare the set of flags ...
     * 
     * @param parseFlags
     * @param containFlags
     * @return
     */
    public static boolean containsOnly(EnumSet<ParserFlags> parseFlags,
            EnumSet<ParserFlags> containFlags) {
        if (parseFlags.containsAll(containFlags)) {
            EnumSet<ParserFlags> temp = parseFlags.clone();
            temp.removeAll(containFlags);
            if (temp.isEmpty()) {
                return true;
            } else {
                return false;
            }
        } else {
            return false;
        }

    }

}

	// End of segment: logic\parser\ParserFlags.java





	/**
	 * origin: logic\parser\ParserManager.java
	 */

/**
 *
 */
public class ParserManager {

    /**
     * @param userInput
     *            the string to be interpreted
     * @return DynamicParseResult which contains task, command and parserFlags
     *         (to determine whether parse succeed) and failedMessage.
     */
    public DynamicParseResult dynamicParsing(String userInput) {
        DynamicParseResult parseResult = new DynamicParseResult();
        DateParser dateParser = new DateParser();
        PriorityParser priorityParser = new PriorityParser();
        DescriptionParser descriptionParser = new DescriptionParser();
        CommandParser commandParser = new CommandParser();
        EnumSet<ParserFlags> parseFlags = tryParse(userInput, dateParser,
                priorityParser, descriptionParser, commandParser);

        parseResult.setCommand(commandParser.getCommand());
        parseResult.setTask(buildTask(parseFlags, dateParser, priorityParser,
                descriptionParser));
        parseResult.setParseFlags(parseFlags);
        parseResult.setDateWordUsed(dateParser.getWordUsed());
        parseResult.setPriorityWordUsed(priorityParser.getWordUsed());
        parseResult.setCommandWordUsed(commandParser.getWordUsed());
        parseResult.setDescriptionWordUsed(descriptionParser.getWordUsed());

        

        System.out.println(parseResult);
        return parseResult;
    }

       /**
     * @param userInput
     *            the string to be interpreted
     * @return ParseResult which contains task, command and parserFlags (to
     *         determine whether parse succeed) and failedMessage.
     */
    public ParseResult interpret(String userInput) {

        final String COMMAND_PARSE_FAILED = "No such command";

        ParseResult parseResult = new ParseResult();
        DateParser dateParser = new DateParser();
        PriorityParser priorityParser = new PriorityParser();
        DescriptionParser descriptionParser = new DescriptionParser();
        CommandParser commandParser = new CommandParser();

        EnumSet<ParserFlags> parseFlags = tryParse(userInput, dateParser,
                priorityParser, descriptionParser, commandParser, parseResult);

        if (!isCommandParsed(parseFlags)) {
            parseResult.setSuccessful(false);
            parseResult.setFailedMessage(COMMAND_PARSE_FAILED);
            return parseResult;
        } else {
            if (!commandParser.getCommand().validate(parseFlags)) {
                parseResult.setSuccessful(false);
                parseResult.setFailedMessage(commandParser.getCommand()
                        .getValidateErrorMessage());
                return parseResult;
            } else {
                if (parseResult.getFailedMessage() == null
                        || parseResult.getFailedMessage().isEmpty()) {
                    parseResult.setSuccessful(true);
                } else {
                    parseResult.setSuccessful(false);
                }
                parseResult.setCommand(commandParser.getCommand());
                parseResult.setTask(buildTask(parseFlags, dateParser,
                        priorityParser, descriptionParser));
                return parseResult;
            }
        }
    }

    /**
     * Build task with the results stored in the parser(s)
     * 
     * @param parseFlags
     *            the set of flags which consist of successful parses
     * @param dateParser
     *            that may consist of the parsed date result
     * @param priorityParser
     *            that may consist of the parsed priority result
     * @param descriptionParser
     *            that may consist of the parsed description result
     * @return
     */
    private Task buildTask(EnumSet<ParserFlags> parseFlags,
            DateParser dateParser, PriorityParser priorityParser,
            DescriptionParser descriptionParser) {

        if (!parseFlags.contains(ParserFlags.DATE_FLAG)) {
            return buildFloatingTask(parseFlags, priorityParser,
                    descriptionParser);
        } else {
            if (dateParser.getNumberOfDates() > 1) {
                return buildTimedTask(parseFlags, dateParser, priorityParser,
                        descriptionParser);
            } else {
                return buildDeadLineTask(parseFlags, dateParser,
                        priorityParser, descriptionParser);
            }
        }

    }

    /**
     * Build deadline with the results stored in the parser(s)
     * 
     * @param parseFlags
     *            the set of flags which consist of successful parses
     * @param dateParser
     *            that may consist of the parsed date result
     * @param priorityParser
     *            that may consist of the parsed priority result
     * @param descriptionParser
     *            that may consist of the parsed description result
     * @return DeadLineTask which consist of description, priority, end date,
     *         end time
     */
    private Task buildDeadLineTask(EnumSet<ParserFlags> parseFlags,
            DateParser dateParser, PriorityParser priorityParser,
            DescriptionParser descriptionParser) {
        if (!parseFlags.contains(ParserFlags.PRIORITY_FLAG)) {
            return new Task(descriptionParser.getDescription(),
                    Task.PRIORITY_NOT_SET, dateParser.getEndDate(),
                    dateParser.getEndTime());
        } else {
            return new Task(descriptionParser.getDescription(),
                    priorityParser.getPriority(), dateParser.getEndDate(),
                    dateParser.getEndTime());
        }
    }

    /**
     * Build timed task with the results stored in the parser(s)
     * 
     * @param parseFlags
     *            the set of flags which consist of successful parses
     * @param dateParser
     *            that may consist of the parsed date result
     * @param priorityParser
     *            that may consist of the parsed priority result
     * @param descriptionParser
     *            that may consist of the parsed description result
     * @return TimedTask which consist of description, priority, end date, end
     *         time, start date, start time
     */
    private Task buildTimedTask(EnumSet<ParserFlags> parseFlags,
            DateParser dateParser, PriorityParser priorityParser,
            DescriptionParser descriptionParser) {
        if (!parseFlags.contains(ParserFlags.PRIORITY_FLAG)) {
            return new Task(descriptionParser.getDescription(),
                    Task.PRIORITY_NOT_SET, dateParser.getStartDate(),
                    dateParser.getStartTime(), dateParser.getEndDate(),
                    dateParser.getEndTime());
        } else {
            return new Task(descriptionParser.getDescription(),
                    priorityParser.getPriority(), dateParser.getStartDate(),
                    dateParser.getStartTime(), dateParser.getEndDate(),
                    dateParser.getEndTime());
        }
    }

    /**
     * Build timed task with the results stored in the parser(s)
     * 
     * @param parseFlags
     *            the set of flags which consist of successful parses
     * @param dateParser
     *            that may consist of the parsed date result
     * @param priorityParser
     *            that may consist of the parsed priority result
     * @param descriptionParser
     *            that may consist of the parsed description result
     * @return FloatingTask which consist of description, priority
     */
    private Task buildFloatingTask(EnumSet<ParserFlags> parseFlags,
            PriorityParser priorityParser, DescriptionParser descriptionParser) {
        if (!parseFlags.contains(ParserFlags.PRIORITY_FLAG)) {
            return new Task(descriptionParser.getDescription(),
                    Task.PRIORITY_NOT_SET);
        } else {
            return new Task(descriptionParser.getDescription(),
                    priorityParser.getPriority());
        }
    }

    /**
     * This function try to parse the userInput with the available parser(s).<br>
     * Parse(s) which are successful are added to the parseFlags. <br>
     * 
     * @param userInput
     *            the String that will be parsed.
     * @param dateParser
     *            the parser which could parse date.
     * @param priorityParser
     *            the parser which could parse priority.
     * @param descriptionParser
     *            the parser which could parse description.
     * @param commandParser
     *            the parser which could parse command.
     * @param parseResult
     * @return parseFlags which consist of successful parses
     */
    public EnumSet<ParserFlags> tryParse(String userInput,
            DateParser dateParser, PriorityParser priorityParser,
            DescriptionParser descriptionParser, CommandParser commandParser,
            ParseResult parseResult) {
        EnumSet<ParserFlags> parseFlags = EnumSet.noneOf(ParserFlags.class);
        final String DESCRIPTION_SEPARATED_ERROR = "Description Should not be separeted";

        System.out.println("to priority parser is " + userInput);

        if (priorityParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.PRIORITY_FLAG);
            userInput = priorityParser.getWordRemaining();
        }

        System.out.println("to date parser " + userInput);
        if (dateParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.DATE_FLAG);
            userInput = dateParser.getWordRemaining();
        }

        System.out.println("to command parser is " + userInput);
        if (commandParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.COMMAND_FLAG);
            userInput = commandParser.getWordRemaining();
        }

        System.out.println("to description parser is " + userInput);

        if (descriptionParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.DESCRIPTION_FLAG);

            if (descriptionParser.isDescriptionSeparated(
                    dateParser.getSeparatedWordRemainings(),
                    commandParser.getWordUsed())) {
                parseResult.setFailedMessage(DESCRIPTION_SEPARATED_ERROR);
            } else {
                userInput = descriptionParser.getWordRemaining();
            }

        }

        return parseFlags;
    }

    /**
     * This function try to parse the userInput with the available parser(s).<br>
     * Parse(s) which are successful are added to the parseFlags. <br>
     * 
     * @param userInput
     *            the String that will be parsed.
     * @param dateParser
     *            the parser which could parse date.
     * @param priorityParser
     *            the parser which could parse priority.
     * @param descriptionParser
     *            the parser which could parse description.
     * @param commandParser
     *            the parser which could parse command.
     * @param parseResult
     * @return parseFlags which consist of successful parses
     */
    public EnumSet<ParserFlags> tryParse(String userInput,
            DateParser dateParser, PriorityParser priorityParser,
            DescriptionParser descriptionParser, CommandParser commandParser) {
        EnumSet<ParserFlags> parseFlags = EnumSet.noneOf(ParserFlags.class);

        System.out.println("to priority parser is " + userInput);

        if (priorityParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.PRIORITY_FLAG);
            userInput = priorityParser.getWordRemaining();
        }

        System.out.println("to date parser " + userInput);
        if (dateParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.DATE_FLAG);
            userInput = dateParser.getWordRemaining();
        }

        System.out.println("to command parser is " + userInput);
        if (commandParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.COMMAND_FLAG);
            userInput = commandParser.getWordRemaining();
        }

        System.out.println("to description parser is " + userInput);

        if (descriptionParser.tryParse(userInput)) {
            parseFlags.add(ParserFlags.DESCRIPTION_FLAG);
            userInput = descriptionParser.getWordRemaining();
        }

        return parseFlags;
    }

    /**
     * <p>
     * Determine whether the valid command is parsed
     * <p>
     * 
     * @param flagSet
     *            the set of ParserFlag to be tested
     * @return if it contains of the Command flag
     */
    public boolean isCommandParsed(EnumSet<ParserFlags> flagSet) {

        if (flagSet.contains(ParserFlags.COMMAND_FLAG)) {
            return true;
        } else {
            return false;
        }
    }
}

	// End of segment: logic\parser\ParserManager.java





	/**
	 * origin: logic\parser\PriorityParser.java
	 */

/**
 *
 */
public class PriorityParser {

    private String wordRemaining;
    private String wordUsed;
    private Priority priority;

    /**
     * <p>
     * The source will be parsed to see if it contains date.
     * 
     * @param source
     *            the String to be parsed
     * @return if source contains valid priority
     */
    public boolean tryParse(String source) {

        priority = MultiMapMatcher.getMatchedKey(
                KeyWordMappingList.getPriorityMultiMap(), source);
        if (isPriorityParsed()) {
            wordUsed = MultiMapMatcher.getMatchedWord(
                    KeyWordMappingList.getPriorityMultiMap(), source);

            assert (wordUsed != null);
            assert (!wordUsed.isEmpty());

            wordRemaining = StringHandler.removeFirstMatched(source, wordUsed);

            return true;
        } else {
            return false;
        }
    }

    /**
     * @return if priority is successfully parsed
     */
    private boolean isPriorityParsed() {
        return priority != null;

    }

    /**
     * @return the priority parsed
     */
    public Priority getPriority() {
        return priority;
    }

    /**
     * @return the word used
     */
    public String getWordUsed() {
        return wordUsed;
    }

    /**
     * @return the word remaining
     */
    public String getWordRemaining() {
        return wordRemaining;
    }

}

	// End of segment: logic\parser\PriorityParser.java





	/**
	 * origin: logic\utility\KeyWordMappingList.java
	 */

/**
 *
 */
public class KeyWordMappingList {

    /**
     * Create multimap based on <T>
     * 
     * @param commandMaps
     *            which consist of keywords mapping
     * @return multimap with key = <T>, value = key word
     */
    @SafeVarargs
    private static <T> Multimap<T, String> createMultiMap(
            final Map<T, Collection<String>>... commandMaps) {
        Multimap<T, String> multiMap = ArrayListMultimap.create();

        for (Map<T, Collection<String>> commandMap : commandMaps) {
            for (T key : commandMap.keySet()) {
                multiMap.putAll(key, commandMap.get(key));
            }

        }
        return multiMap;
    }

    /**
     * Get all permutation based on priority words and key words
     * 
     * @param priorityWords
     *            the words for priority
     * @param keyWords
     *            the words for keywords
     * @return ArrayList containing the permutation
     */
    private static ArrayList<String> getPermutation(String priorityWords[],
            String keyWords[]) {
        ArrayList<String> list = new ArrayList<String>();

        for (String priorityWord : priorityWords) {
            for (String keyWord : keyWords) {
                list.add(priorityWord + " " + keyWord);
            }
        }

        for (String keyWord : keyWords) {
            for (String priorityWord : priorityWords) {
                list.add(keyWord + " " + priorityWord);
            }
        }

        return list;

    }

    /**
     * @return ImmutableMap containing keywords for add
     */
    public static ImmutableMap<Command, Collection<String>> getAddCommandMap() {
        Command addCommand = new AddCommand();
        return ImmutableMap.<Command, Collection<String>> of(addCommand,
                Arrays.asList("add", "new", "create", "cre8"));
    }

    /**
     * @return ImmutableMap containing keywords for complete
     */
    public static ImmutableMap<Command, Collection<String>> getCompleteCommandMap() {
        Command completeCommand = new CompleteCommand();
        return ImmutableMap.<Command, Collection<String>> of(completeCommand,
                Arrays.asList("complete", "done", "finish", "tick"));
    }

    /**
     * @return ImmutableMap containing keywords for incomplete
     */
    public static ImmutableMap<Command, Collection<String>> getIncompleteCommandMap() {
        Command uncompleteCommand = new IncompleteCommand();
        return ImmutableMap.<Command, Collection<String>> of(uncompleteCommand,
                Arrays.asList("incomplete", "undone", "cancel", "uncomplete",
                        "untick"));
    }

    /**
     * @return ImmutableMap containing keywords for delete
     */
    public static ImmutableMap<Command, Collection<String>> getDeleteCommandMap() {
        Command deleteCommand = new DeleteCommand();
        return ImmutableMap.<Command, Collection<String>> of(deleteCommand,
                Arrays.asList("delete", "del", "remove"));
    }

    /**
     * @return ImmutableMap containing keywords for exit
     */
    public static ImmutableMap<Command, Collection<String>> getExitCommandMap() {
        Command exitCommand = new ExitCommand();
        return ImmutableMap.<Command, Collection<String>> of(exitCommand,
                Arrays.asList("exit", "quit"));
    }

    /**
     * @return ImmutableMap containing keywords for search
     */
    public static ImmutableMap<Command, Collection<String>> getSearchCommandMap() {
        Command searchCommand = new SearchCommand();
        return ImmutableMap.<Command, Collection<String>> of(searchCommand,
                Arrays.asList("search", "find", "locate"));
    }

    /**
     * @return ImmutableMap containing keywords for edit
     */
    public static ImmutableMap<Command, Collection<String>> getEditCommandMap() {
        Command editCommand = new EditCommand();
        return ImmutableMap.<Command, Collection<String>> of(editCommand,
                Arrays.asList("edit", "modify", "change"));
    }

    /**
     * @return ImmutableMap containing keywords for view
     */
    public static ImmutableMap<Command, Collection<String>> getViewCommandMap() {
        Command viewCommand = new ViewCommand();
        return ImmutableMap.<Command, Collection<String>> of(viewCommand,
                Arrays.asList("view", "viewing", "read", "reading", "see",
                        "get"));
    }

    /**
     * @return ImmutableMap containing keywords for undo
     */
    public static ImmutableMap<Command, Collection<String>> getUndoCommandMap() {
        Command undoCommand = new UndoCommand();
        return ImmutableMap.<Command, Collection<String>> of(undoCommand,
                Arrays.asList("undo"));
    }

    /**
     * @return ImmutableMap containing keywords for redo
     */
    public static ImmutableMap<Command, Collection<String>> getRedoCommandMap() {
        Command redoCommand = new RedoCommand();
        return ImmutableMap.<Command, Collection<String>> of(redoCommand,
                Arrays.asList("redo"));
    }

    /**
     * This function create a map of commands and add them to the multi map. It
     * contains the Command and String pair, where the string is the keyword for
     * command. In future implementation, the multi map will be generated by
     * reading from a file
     */
    public static Multimap<Command, String> getCommandMultiMap() {
        ImmutableMap<Command, Collection<String>> addCommandMap = getAddCommandMap();
        ImmutableMap<Command, Collection<String>> completedCommandMap = getCompleteCommandMap();
        ImmutableMap<Command, Collection<String>> uncompletedCommandMap = getIncompleteCommandMap();
        ImmutableMap<Command, Collection<String>> deleteCommandMap = getDeleteCommandMap();
        ImmutableMap<Command, Collection<String>> exitCommandMap = getExitCommandMap();
        ImmutableMap<Command, Collection<String>> searchCommandMap = getSearchCommandMap();
        ImmutableMap<Command, Collection<String>> editCommandMap = getEditCommandMap();
        ImmutableMap<Command, Collection<String>> viewCommandMap = getViewCommandMap();
        ImmutableMap<Command, Collection<String>> undoCommandMap = getUndoCommandMap();
        ImmutableMap<Command, Collection<String>> redoCommandMap = getRedoCommandMap();

        return createMultiMap(addCommandMap, completedCommandMap,
                uncompletedCommandMap, deleteCommandMap, exitCommandMap,
                searchCommandMap, editCommandMap, viewCommandMap,
                undoCommandMap, redoCommandMap);
    }

    /**
     * @return ImmutableMap containing keywords for high priority
     */
    public static ImmutableMap<Priority, Collection<String>> getHighPriority() {
        final String PRIORITY_WORD[] = { "priority", "pri" };
        final String KEYWORDS_FOR_HIGH[] = { "high", "urgent", "top",
                "crucial", "important" };

        return ImmutableMap.<Priority, Collection<String>> of(
                Priority.PRIORITY_HIGH,
                getPermutation(PRIORITY_WORD, KEYWORDS_FOR_HIGH));
    }

    /**
     * @return ImmutableMap containing keywords for medium priority
     */
    public static ImmutableMap<Priority, Collection<String>> getMediumPriority() {
        final String PRIORITY_WORD[] = { "priority", "pri" };
        final String KEYWORDS_FOR_MEDIUM[] = { "medium", "med", "normal",
                "neutral", "moderate" };

        return ImmutableMap.<Priority, Collection<String>> of(
                Priority.PRIORITY_MEDIUM,
                getPermutation(PRIORITY_WORD, KEYWORDS_FOR_MEDIUM));
    }

    /**
     * @return ImmutableMap containing keywords for low priority
     */
    public static ImmutableMap<Priority, Collection<String>> getLowPriority() {
        final String PRIORITY_WORD[] = { "priority", "pri" };
        final String KEYWORDS_FOR_LOW[] = { "low", "none", "never", "no",
                "ignore" };

        return ImmutableMap.<Priority, Collection<String>> of(
                Priority.PRIORITY_LOW,
                getPermutation(PRIORITY_WORD, KEYWORDS_FOR_LOW));
    }

    /**
     * @return ImmutableMap containing keywords for someday
     */
    public static ImmutableMap<LocalDate, Collection<String>> getSomeDayKeyWord() {

        return ImmutableMap.<LocalDate, Collection<String>> of(
                Task.DATE_NOT_SET,
                Arrays.asList("someday", "no date", "no day", "some day"));
    }

    /**
     * This function create a map of commands and add them to the multi map. It
     * contains the Priority and String pair, where the string is the keyword
     * for command. In future implementation, the multi map will be generated by
     * reading from a file
     */
    public static Multimap<Priority, String> getPriorityMultiMap() {
        ImmutableMap<Priority, Collection<String>> lowPriorityMap = getLowPriority();
        ImmutableMap<Priority, Collection<String>> MediumPriorityMap = getMediumPriority();
        ImmutableMap<Priority, Collection<String>> HighPriorityMap = getHighPriority();

        return createMultiMap(lowPriorityMap, MediumPriorityMap,
                HighPriorityMap);
    }

    /**
     * This function create a map of commands and add them to the multi map. It
     * contains the Command and String pair, where the string is the keyword for
     * command. In future implementation, the multi map will be generated by
     * reading from a file
     */
    public static Multimap<Command, String> getCompletedUnCompleteMultiMap() {
        ImmutableMap<Command, Collection<String>> completedCommandMap = getCompleteCommandMap();
        ImmutableMap<Command, Collection<String>> uncompletedCommandMap = getIncompleteCommandMap();

        return createMultiMap(completedCommandMap, uncompletedCommandMap);
    }

}

	// End of segment: logic\utility\KeyWordMappingList.java





	/**
	 * origin: logic\utility\MultiMapMatcher.java
	 */

/**
 *
 */
public class MultiMapMatcher {

    /**
     * This function search for values inside the multi-map that matches with
     * any word inside the input Return key which contains the value, return
     * null if no matches
     * 
     * @param multimap
     * @param input
     * @return
     */
    public static <K> K getMatchedKey(Multimap<K, String> multimap, String input) {
        if (input == null || input.isEmpty()) {
            return null;
        }

        input = input.toLowerCase();
        input = " " + input + " ";

        for (K key : multimap.keys()) {
            for (String value : multimap.get(key)) {
                if (input.contains(" " + value.toLowerCase() + " ")) {
                    return key;
                }
            }
        }
        return null;
    }

    /**
     * This function search for values inside the multi-map that is contains
     * within the input Return key which contains the value, return null if no
     * matches
     * 
     * @param multimap
     * @param input
     * @return
     */
    public static <K> K getContainsKey(Multimap<K, String> multimap,
            String input) {
        if (input == null || input.isEmpty()) {
            return null;
        }

        input = input.toLowerCase();

        for (K key : multimap.keys()) {
            for (String value : multimap.get(key)) {
                if (input.contains(value.toLowerCase())) {
                    return key;
                }
            }
        }
        return null;
    }

    /**
     * This function search for values inside the multi-map that matches with
     * any word inside the input Return the value which matches, return null if
     * no matches
     * 
     * @param multimap
     * @param input
     * @return
     */
    public static <K> String getMatchedWord(Multimap<K, String> multimap,
            String input) {
        if (input == null || input.isEmpty()) {
            return null;
        }

        input = input.toLowerCase();
        input = " " + input + " ";

        for (K key : multimap.keys()) {
            for (String value : multimap.get(key)) {
                if (input.contains(" " + value.toLowerCase() + " ")) {
                    return value;
                }
            }
        }
        return null;
    }

    /**
     * This function replace any word inside the input that matches with the
     * values in the multi-map The word replaced will be the key to the value
     * 
     * @param multimap
     * @param input
     * @return replaced input if there's any match
     */
    public static String replaceMatchedWithKey(
            Multimap<String, String> multimap, String input) {
        input = " " + input + " ";

        for (String key : multimap.keys()) {
            for (String value : multimap.get(key)) {
                if (input.toLowerCase().contains(
                        " " + value.toLowerCase() + " ")) {
                    input = input.toLowerCase().replaceAll(
                            " " + value.toLowerCase() + " ", " " + key + " ");
                }
            }
        }
        return input.trim();
    }
}

	// End of segment: logic\utility\MultiMapMatcher.java





	/**
	 * origin: logic\utility\StringHandler.java
	 */

/**
 *
 */
public class StringHandler {

    /**
     * Get the first word (pure alphabet word) from the String
     * 
     * @param source
     *            the string where the first word is to be extracted
     * @return the extracted first word or null if there is no first word
     */
    public static String getFirstWord(String source) {
        if (source == null) {
            return null;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return null;
        }

        if (containsSpace(source)) {

            final int FIRST_WORD_GROUP = 1;
            String firstWordRegex = "^[^A-z]*([A-z]+)";
            Pattern pattern = Pattern.compile(firstWordRegex);
            Matcher matcher = pattern.matcher(source);
            if (matcher.find()) {
                return matcher.group(FIRST_WORD_GROUP);
            } else {
                return null;
            }
        } else {
            return source;
        }
    }

    /**
     * Check string if it contains space
     * 
     * @param source
     *            the string to check
     * @return if it contains space
     */
    private static boolean containsSpace(String source) {
        return source.contains(" ");
    }

    /**
     * Get the last word (pure alphabet word) from a String
     * 
     * @param source
     *            the string where the last word is to be extracted
     * @return the extracted last word or null if there is no last word
     */
    public static String getLastWord(String source) {
        if (source == null) {
            return null;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return null;
        }

        if (containsSpace(source)) {
            final int LAST_WORD_GROUP = 1;
            String lastWordRegex = "\\s([A-z]+)[^A-z]*$";
            Pattern pattern = Pattern.compile(lastWordRegex);
            Matcher matcher = pattern.matcher(source);
            if (matcher.find()) {
                return matcher.group(LAST_WORD_GROUP);
            } else {
                return null;
            }

        } else {
            return source;
        }
    }

    public static String[] getSeparatedWord(String source, String word) {
        return source.split(word);
    }

    /**
     * @param source
     *            the source that require a particular word to be removed
     * @param toRemove
     *            the String that is to be removed
     * @return the new source without the toRemove word
     *         <p>
     *         This function remove the first word that matches with the
     *         toRemove word
     *         <p>
     */
    public static String removeFirstMatched(String source, String toRemove) {
        if (source != null && toRemove != null) {
            toRemove = toRemove.trim();
            String newWord = source.replaceFirst(toRemove, "");
            return newWord.trim();
        }

        return source;
    }
    
    /**
     * @param source
     *            the source that require a particular word to be removed
     * @param toRemove
     *            the String that is to be removed
     * @return the new source without the toRemove word
     *         <p>
     *         This function remove the first word that matches with the
     *         toRemove word
     *         <p>
     */
    public static String removeFirstMatchedWord(String source, String toRemove) {
        if (source != null && toRemove != null) {
            source = source.trim();
            toRemove = toRemove.trim();
            final String SPACE = " ";
            source = SPACE + source + SPACE;
            toRemove = SPACE + toRemove + SPACE;
            
            String newWord = source.replaceFirst(toRemove, "");
            return newWord.trim();
        }

        return source;
    }

    /**
     * @param source
     *            the source that require a particular word to be removed
     * @param toRemove
     *            the String that is to be removed
     * @return the new source without the toRemove word
     *         <p>
     *         This function remove the last word that matches with the toRemove
     *         word
     *         <p>
     */
    public static String removeLastMatch(String source, String toRemove) {
        if (source != null && toRemove != null) {
            toRemove = toRemove.trim() + "$";
            toRemove = toRemove.trim();
            String newWord = source.replaceFirst(toRemove, "");
            return newWord.trim();
        }

        return source;
    }

    /**
     * @param source
     *            the source that require a particular word to be removed
     * @param toRemove
     *            the String that is to be removed
     * @return the new source without the toRemove word
     *         <p>
     *         This function remove all matches with the toRemove word
     *         <p>
     */
    public static String removeAll(String source, String toRemove) {
        if (source != null && toRemove != null) {
            toRemove = toRemove.trim();
            String newWord = source.replaceAll(toRemove, "");
            return newWord.trim();
        }

        return source;
    }

    public static String[] splitString(final String source,
            final String delimiter) {
        return source.replaceFirst("^" + delimiter, "").split(delimiter);
    }

    /**
     * @param source
     *            which may consist of DD/MM/YYYY format
     * @return replaced string with YYYY/MM/DD format
     */
    public static String convertFormalDate(String source) {
        final int yearGroup = 3;
        final int monthGroup = 2;
        final int dayGroup = 1;
        final String ddmmyyyyRegex = "([012]?[0-9]|3[01])[/-](0?[1-9]|1[012])[/-]((18|19|20|21)\\d\\d)";
        Pattern pattern = Pattern.compile(ddmmyyyyRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(result, matcher.group(yearGroup) + "/"
                    + matcher.group(monthGroup) + "/" + matcher.group(dayGroup));
        }
        matcher.appendTail(result);

        return result.toString();

    }

    public static String convertImplicitFormalDate(String source) {
        source = convertDateDDMM(source);
        source = convertDateDDMMYY(source);
        return source;
    }

    /**
     * This function convert date in DD/MM/YY or DD-MM-YY format to DD/MM/20YY
     * format
     * 
     * @param source
     *            which consist of DD/MM/YY format
     * @return replaced string with DD/MM/20YY format
     */
    public static String convertDateDDMMYY(String source) {
        final int inferredYear = 20;

        final int startGroup = 1;
        final int dayGroup = 2;
        final int monthGroup = 3;
        final int yearGroup = 4;
        final int endGroup = 5;

        final String ddmmyyRegex = "([^\\w]|^)+([012]?[0-9]|3[01])[/-](0?[1-9]|1[012])[/-](\\d\\d)([^\\w]|$)+";
        Pattern pattern = Pattern.compile(ddmmyyRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find()) {
            matcher.appendReplacement(
                    result,
                    matcher.group(startGroup) + matcher.group(dayGroup) + "/"
                            + matcher.group(monthGroup) + "/" + inferredYear
                            + matcher.group(yearGroup)
                            + matcher.group(endGroup));
        }

        matcher.appendTail(result);
        return result.toString();
    }

    /**
     * This function convert date in DD/MM or DD-MM format to DD/MM/YYYY format
     * 
     * @param source
     *            which consist of DD/MM format
     * @return replaced string with DD/MM/YYYY format
     */
    public static String convertDateDDMM(String source) {
        final int inferredYear = LocalDateTime.now().getYear();
        final int startGroup = 1;
        final int dayGroup = 2;
        final int monthGroup = 3;
        final int endGroup = 4;

        final String ddmmyyRegex = "([^\\w]|^)+([012]?[0-9]|3[01])[/-](0?[1-9]|1[012])([^\\w]|$)";
        Pattern pattern = Pattern.compile(ddmmyyRegex);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        while (matcher.find() && !matcher.group(endGroup).matches("/|-")) {
            matcher.appendReplacement(result, matcher.group(startGroup)
                    + matcher.group(dayGroup) + "/" + matcher.group(monthGroup)
                    + "/" + inferredYear + matcher.group(endGroup));
        }

        matcher.appendTail(result);
        return result.toString();

    }

    /**
     * Get the digit after first pure alphabet word from the source
     * 
     * @param source
     *            the source which contains the digit
     * @return digit after first word, null if invalid
     */
    public static String getDigitAfterFirstWord(String source) {
        final String theRegex = "^[^A-z]*[A-z]+\\s+(\\d+)";
        return getMatchedRegex(source, theRegex);

    }

    /**
     * Get the digit after last pure alphabet word from the source
     * 
     * @param source
     *            the source which contains the digit
     * @return digit after last word, null if invalid
     */
    public static String getDigitAfterLastWord(String source) {
        final String theRegex = "\\s[A-z]+\\s+(\\d+)[^A-z]*$";
        return getMatchedRegex(source, theRegex);
    }

    /**
     * Remove the digit after first pure alphabet word from the source
     * 
     * @param source
     *            the source which contains the digit
     * @return source with removed digit if found, source if not found
     */
    public static String removeDigitAfterFirstWord(String source) {
        final String theRegex = "^[^A-z]*[A-z]+\\s+(\\d+)";
        return removeMatchedRegex(source, theRegex);

    }

    /**
     * Remove the digit after last pure alphabet word from the source
     * 
     * @param source
     *            the source which contains the digit
     * @return source with removed digit if found, source if not found
     */
    public static String removeDigitAfterLastWord(String source) {
        final String theRegex = "\\s[A-z]+\\s+(\\d+)[^A-z]*$";
        return removeMatchedRegex(source, theRegex);
    }

    /**
     * remove matched regex pattern
     * 
     * @param source
     * @param regexPattern
     * @return
     */
    private static String removeMatchedRegex(String source, String regexPattern) {

        final int MATCHED = 1;
        if (source == null) {
            return source;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return source;
        }

        Pattern pattern = Pattern.compile(regexPattern);
        Matcher matcher = pattern.matcher(source);
        StringBuffer result = new StringBuffer();

        if (matcher.find()) {
            matcher.appendReplacement(result, "");
            System.out.println(matcher.group(MATCHED));
        }

        matcher.appendTail(result).toString();
        System.out.println(result);

        return result.toString();

    }

    /**
     * return matched regex pattern or null is there is isn't
     * 
     * @param source
     * @param regexPattern
     * @return
     */
    private static String getMatchedRegex(String source, String regexPattern) {

        final int MATCHED = 1;
        if (source == null) {
            return null;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return null;
        }

        Pattern pattern = Pattern.compile(regexPattern);
        Matcher matcher = pattern.matcher(source);

        if (matcher.find()) {
            return matcher.group(MATCHED);
        } else {
            return null;
        }
    }

    /**
     * @param source
     *            the string where the first word is to be extracted
     * @return the extracted first word or null if there is no first word
     */
    public static String removeFirstWord(String source) {
        if (source == null) {
            return null;
        }

        source = source.trim();

        if (source.isEmpty()) {
            return null;
        }

        if (containsSpace(source)) {
            return source.replaceFirst("^.+?(?=\\s)", "");
        } else {
            return "";
        }

    }

    /**
     * This function search for words that matches with values at keyArrays
     * 
     * @param source
     *            the string that is to be searched
     * @param keyArrays
     *            the string arrays which have the keys to search for
     * @return if it contains word
     */
    public static boolean containsWord(String source, String[]... keyArrays) {
        source = " " + source.toLowerCase() + " ";

        for (String[] keyArray : keyArrays) {
            for (String key : keyArray) {
                if (!key.isEmpty()) {
                    key = " " + key.toLowerCase() + " ";
                    if (source.contains(key)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    
    /**
     * This function search for words that matches with values at keyArrays
     * 
     * @param source
     *            the string that is to be searched
     * @param keyArrays
     *            the string arrays which have the keys to search for
     * @return the containing word
     */
    public static String getContainsWord(String source, String[]... keyArrays) {
        source = " " + source.toLowerCase() + " ";

        for (String[] keyArray : keyArrays) {
            for (String key : keyArray) {
                if (!key.isEmpty()) {
                    key = " " + key.toLowerCase() + " ";
                    if (source.contains(key)) {
                        return key;
                    }
                }
            }
        }
        return "";
    }
    

    /**
     * @param source
     *            the string that will be searched
     * @return the first integer if it contains, null if it does not.
     */
    public static String getIntegerFromFirstSlot(String source) {
        String regexPattern = "(^\\d+)";
        return getMatchedRegex(source, regexPattern);
    }

    /**
     * @param source
     *            the arguments passed in by the user
     * @return Integer that is parsed from the string, MAX_VALUE if it is not
     *         parsable
     */
    public static int parseStringToInteger(String source) {

        if (isValidString(source)) {
            source = source.trim();
            if (isInteger(source)) {
                return Integer.parseInt(source);
            }
        }
        return Integer.MAX_VALUE;
    }

    /**
     * @param userInput
     *            the user input
     * @return whether the string could be parsed
     */
    private static boolean isInteger(String userInput) {

        try {
            Integer.parseInt(userInput);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    /**
     * @param addedInput
     *            the input to be added
     * @return whether it is a valid string
     */
    private static boolean isValidString(String addedInput) {
        return addedInput != null && addedInput.length() > 0;
    }
}

	// End of segment: logic\utility\StringHandler.java





	/**
	 * origin: logic\utility\Task.java
	 */

/**
 *
 */
public class Task {
    public static final LocalTime TIME_NOT_SET = LocalTime.MAX;
    public static final LocalDate DATE_NOT_SET = LocalDate.MAX;
    public static final Priority PRIORITY_NOT_SET = Priority.PRIORITY_UNDEFINED;
    public static final boolean DEFAULT_COMPLETE_STATUS = false;

    private static final int INITIAL_ID = 0;

    private static int createID = INITIAL_ID;
    private int uniqueID = createID;
    private String description;
    private Priority priority;
    private LocalDate startDate;
    private LocalTime startTime;
    private LocalDate endDate;
    private LocalTime endTime;
    private boolean isCompleted;

    /**
     * Copy Constructor
     * 
     * @param task
     *            to be copied
     */
    public Task(Task task) {
        this(task.uniqueID, task.description, task.priority, task.startDate,
                task.startTime, task.endDate, task.endTime, task.isCompleted);
    }

    // blank task constructor
    public Task() {
        createID++;

        this.priority = PRIORITY_NOT_SET;
        this.startDate = this.endDate = DATE_NOT_SET;
        this.startTime = this.endTime = TIME_NOT_SET;
        this.isCompleted = DEFAULT_COMPLETE_STATUS;
    }

    /**
     * Constructor for <b>timed</b> task without completed status
     * 
     * @param description
     * @param priority
     * @param startDate
     * @param startTime
     * @param endDate
     * @param endTime
     */
    public Task(String description, Priority priority, LocalDate startDate,
            LocalTime startTime, LocalDate endDate, LocalTime endTime) {

        createID++;

        this.description = description;
        this.priority = priority;
        this.startDate = startDate;
        this.startTime = startTime;
        this.endDate = endDate;
        this.endTime = endTime;
        isCompleted = DEFAULT_COMPLETE_STATUS;
    }

    /**
     * Constructor for <b>timed</b> task with completed status
     * 
     * @param description
     * @param priority
     * @param startDate
     * @param startTime
     * @param endDate
     * @param endTime
     * @param isCompleted
     */
    public Task(String description, Priority priority, LocalDate startDate,
            LocalTime startTime, LocalDate endDate, LocalTime endTime,
            boolean isCompleted) {

        createID++;

        this.description = description;
        this.priority = priority;
        this.startDate = startDate;
        this.startTime = startTime;
        this.endDate = endDate;
        this.endTime = endTime;
        this.isCompleted = isCompleted;
    }

    /**
     * Constructor for <b>deadline</b> task without completed status
     * 
     * @param description
     * @param priority
     * @param endDate
     * @param endTime
     */
    public Task(String description, Priority priority, LocalDate endDate,
            LocalTime endTime) {

        createID++;

        this.description = description;
        this.priority = priority;
        this.endDate = endDate;
        this.endTime = endTime;
        this.startDate = DATE_NOT_SET;
        this.startTime = TIME_NOT_SET;
        this.isCompleted = DEFAULT_COMPLETE_STATUS;
    }

    /**
     * Constructor for <b>deadline</b> task with completed status
     * 
     * @param description
     * @param priority
     * @param endDate
     * @param endTime
     * @param isCompleted
     */
    public Task(String description, Priority priority, LocalDate endDate,
            LocalTime endTime, boolean isCompleted) {

        createID++;

        this.description = description;
        this.priority = priority;
        this.endDate = endDate;
        this.endTime = endTime;
        this.isCompleted = isCompleted;
        this.startDate = DATE_NOT_SET;
        this.startTime = TIME_NOT_SET;
    }

    /**
     * Constructor for <b>floating</b> task without completed status
     * 
     * @param description
     * @param priority
     */
    public Task(String description, Priority priority) {

        createID++;

        this.description = description;
        this.priority = priority;

        this.startDate = this.endDate = DATE_NOT_SET;
        this.startTime = this.endTime = TIME_NOT_SET;
        this.isCompleted = DEFAULT_COMPLETE_STATUS;
    }

    /**
     * Constructor for <b>deadline</b> task with completed status
     * 
     * @param description
     * @param priority
     * @param isCompleted
     */
    public Task(String description, Priority priority, boolean isCompleted) {

        createID++;

        this.description = description;
        this.priority = priority;
        this.isCompleted = isCompleted;

        this.startDate = this.endDate = DATE_NOT_SET;
        this.startTime = this.endTime = TIME_NOT_SET;
    }

    public String getDateTimeString() {
        final String EMPTY_STRING = "";
        final String TIME_CONNECTOR = " at ";
        final String DATE_CONNECTOR = " to ";
        final LocalDate CORRECT_YEAR_FORMAT = LocalDate.of(1, 1, 1);
        DateTimeFormatter dateFormatter;

        String dateString = EMPTY_STRING;

        if (startDate.isAfter(CORRECT_YEAR_FORMAT)
                && endDate.isAfter(CORRECT_YEAR_FORMAT)) {
            dateFormatter = DateTimeFormatter.ofPattern("dd/MM/yyyy");
        } else {
            dateFormatter = DateTimeFormatter.ofPattern("dd/MM/YYYY");
        }

        DateTimeFormatter timeFormatter = DateTimeFormatter
                .ofPattern("hh:mm a");

        if (startDate.equals(DATE_NOT_SET)) {
            if (endDate.equals(DATE_NOT_SET)) {
                return dateString;
            } else {
                dateString += endDate.format(dateFormatter);
                if (!endTime.equals(TIME_NOT_SET)) {
                    dateString += TIME_CONNECTOR
                            + endTime.format(timeFormatter);
                }
                return dateString;
            }
        } else {
            dateString += startDate.format(dateFormatter);
        }

        if (!startTime.equals(TIME_NOT_SET)) {
            dateString += TIME_CONNECTOR + startTime.format(timeFormatter);
        }

        if (endDate.equals(DATE_NOT_SET)) {
            return dateString;
        } else {
            dateString += DATE_CONNECTOR + endDate.format(dateFormatter);
        }

        if (!endTime.equals(TIME_NOT_SET)) {
            dateString += TIME_CONNECTOR + endTime.format(timeFormatter);
        }

        return dateString;

    }

    /**
     * @param uniqueID
     * @param description
     * @param priority
     * @param startDate
     * @param startTime
     * @param endDate
     * @param endTime
     * @param isCompleted
     */
    public Task(int uniqueID, String description, Priority priority,
            LocalDate startDate, LocalTime startTime, LocalDate endDate,
            LocalTime endTime, boolean isCompleted) {
        super();
        this.uniqueID = uniqueID;
        this.description = description;
        this.priority = priority;
        this.startDate = startDate;
        this.startTime = startTime;
        this.endDate = endDate;
        this.endTime = endTime;
        this.isCompleted = isCompleted;
    }

    @Override
    public String toString() {
        return "description:[" + description + "],startDate:[" + startDate
                + "," + startTime + "],endDate:[" + endDate + "," + endTime
                + "],Priority:[" + priority + "]" + "uniqueID:" + "["
                + uniqueID + "]";

    }

    /**
     * @return the iD
     */
    public int getUniqueID() {
        return uniqueID;
    }

    public static int getCreateID() {
        return createID;
    }

    /**
     * @param iD
     *            the iD to set
     */
    public void setUniqueID(int iD) {
        uniqueID = iD;
    }

    /**
     * @return the priority
     */
    public Priority getPriority() {
        if (priority == null) {
            return PRIORITY_NOT_SET;
        } else {
            return priority;
        }
    }

    /**
     * @param priority
     *            the priority to set
     */
    public void setPriority(Priority priority) {
        this.priority = priority;
    }

    /**
     * @return the start
     */
    public LocalDate getStartDate() {
        if (startDate == null) {
            return DATE_NOT_SET;
        } else {
            return startDate;
        }

    }

    /**
     * @param start
     *            the start to set
     */
    public void setStartDate(LocalDate start) {
        this.startDate = start;
    }

    /**
     * @return the end
     */
    public LocalDate getEndDate() {
        if (endDate == null) {
            return DATE_NOT_SET;
        } else {
            return endDate;
        }

    }

    /**
     * @param end
     *            the end to set
     */
    public void setEndDate(LocalDate end) {
        this.endDate = end;
    }

    /**
     * @return the isCompleted
     */
    public boolean getCompleted() {
        return isCompleted;

    }

    /**
     * @param isCompleted
     *            the isCompleted to set
     */
    public void setCompleted(boolean isComplete) {
        this.isCompleted = isComplete;
    }

    /**
     * @return the description
     */
    public String getDescription() {
        return description;
    }

    /**
     * @param description
     *            the description to set
     */
    public void setDescription(String description) {
        this.description = description;
    }

    /**
     * @return the startTime
     */
    public LocalTime getStartTime() {
        if (startTime == null) {
            return TIME_NOT_SET;
        } else {
            return startTime;
        }
    }

    /**
     * @param startTime
     *            the startTime to set
     */
    public void setStartTime(LocalTime startTime) {
        this.startTime = startTime;
    }

    /**
     * @return the endTime
     */
    public LocalTime getEndTime() {
        if (endTime == null) {
            return TIME_NOT_SET;
        } else {
            return endTime;
        }
    }

    /**
     * @param endTime
     *            the endTime to set
     */
    public void setEndTime(LocalTime endTime) {
        this.endTime = endTime;
    }

    /**
     * @return the testPriority
     */

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#equals(java.lang.Object)
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Task other = (Task) obj;
        if (description == null) {
            if (other.description != null)
                return false;
        } else if (!description.equals(other.description))
            return false;
        if (endDate == null) {
            if (other.endDate != null)
                return false;
        } else if (!endDate.equals(other.endDate))
            return false;
        if (endTime == null) {
            if (other.endTime != null)
                return false;
        } else if (!endTime.equals(other.endTime))
            return false;
        if (isCompleted != other.isCompleted)
            return false;
        if (priority != other.priority)
            return false;
        if (startDate == null) {
            if (other.startDate != null)
                return false;
        } else if (!startDate.equals(other.startDate))
            return false;
        if (startTime == null) {
            if (other.startTime != null)
                return false;
        } else if (!startTime.equals(other.startTime))
            return false;
        if (uniqueID != other.uniqueID)
            return false;
        return true;
    }
}

	// End of segment: logic\utility\Task.java





	/**
	 * origin: testCases\AllTests.java
	 */

/**
 *
 */
@RunWith(Suite.class)
@SuiteClasses({ ObservableListTest.class, StringHandlerTest.class,
        ParserManagerTest.class, CommandValidateTest.class,
        DateParserTest.class,
        PriorityParserTest.class, UndoHandlerTest.class, BasicDataHandlerTest.class, TestLogicManager.class })

public class AllTests {
    static {
        ClassLoader.getSystemClassLoader().setDefaultAssertionStatus(true);
    }

    public static void main(String args[]) {
        org.junit.runner.JUnitCore.main("AllTests");
    }

}

	// End of segment: testCases\AllTests.java





	/**
	 * origin: testCases\DateParserTest.java
	 */

//@formatter:off
/**
 * 
 * Possible format for formal dates are
 * Date range [1..31]
 * Month Range [1..12]
 * Year Range [00..99] [0000...9999]
 *+-------------+--------------+-------------+
 *| Date Format | Month Format | Year Format |
 *+-------------+--------------+-------------+
 *| DD          | MM           | YYYY        |
 *+-------------+--------------+-------------+
 *| D           | M            | YY          |
 *+-------------+--------------+-------------+
 *
 * Invalid format for formal dates are
 *+---------------------+----------------------+---------------------+
 *| Invalid Date Format | Invalid Month Format | Invalid Year Format |
 *+---------------------+----------------------+---------------------+
 *| 0                   | 0                    | 100                 |
 *+---------------------+----------------------+---------------------+
 *| 32                  | 13                   | 10000               |
 *+---------------------+----------------------+---------------------+
 *
 * Possible arrangement for formal date are
 *+---------------------+---------------------+
 *| Date / Month / Year | Year / Month / Date |
 *+---------------------+---------------------+
 *| DD / MM / YYYY      | YYYY / MM / DD      |
 *+---------------------+---------------------+
 *| DD / MM / YY        |                     |
 *+---------------------+---------------------+
 *| D / MM / YYYY       | YYYY / M / DD       |
 *+---------------------+---------------------+
 *| D / MM / YY         |                     |
 *+---------------------+---------------------+
 *| DD / M / YYYY       | YYYY / MM / D       |
 *+---------------------+---------------------+
 *| DD / M / YY         |                     |
 *+---------------------+---------------------+
 *| D / M / YYYY        | YYYY / M / D        |
 *+---------------------+---------------------+
 *| D / M / YY          |                     |
 *+---------------------+---------------------+
 * 
 * Using heuristic evaluation, we can eliminate most of the test case leaving the following
 * for Date/Month/Year/format
 * +------+-------+-------+
 *| Date | Month | Year  |
 *+------+-------+-------+
 *| 1    | 1     | 00    |
 *+------+-------+-------+
 *| 31   | 12    | 9999  |
 *+------+-------+-------+
 *| 10   | 9     | 99    |
 *+------+-------+-------+
 *| 11   | 11    | 0000  |
 *+------+-------+-------+
 *| 0    | 5     | 88    |
 *+------+-------+-------+
 *| 32   | 8     | 1024  |
 *+------+-------+-------+
 *| 1    | 0     | 2048  |
 *+------+-------+-------+
 *| 30   | 13    | 74    |
 *+------+-------+-------+
 *| 11   | 11    | 100   |
 *+------+-------+-------+
 *| 1    | 1     | 10000 |
 *+------+-------+-------+
 *
 * Since month is still in the middle slot, we will only test Date and Year 
 * For Year/Month/Date format
 * +-------+-------+------+
 *| Year  | Month | Date |
 *+-------+-------+------+
 *| 0000  | 1     | 1    |
 *+-------+-------+------+
 *| 9999  | 12    | 31   |
 *+-------+-------+------+
 *| 999    | 9    | 10   |
 *+-------+-------+------+
 *| 10000 | 11    | 11   |
 *+-------+-------+------+
 *| 8888  | 5     | 0    |
 *+-------+-------+------+
 *| 1024  | 8     | 32   |
 *+-------+-------+------+
 */
//@formatter:on

public class DateParserTest {

    @Test
    public void test() {
        parseValidDateWithDMY("1/1/00");
        parseValidDateWithDDMMYY("31/12/9999");
        parseValidDateWithDDMYY("10/9/99");
        parseValidDateWithDDMMYYYY("12/11/0000");
        parseInvalidDateWithDMYY("0/5/88");
        parseInvalidDateWithDDMYYYY("32/8/1024");
        parseInvalidDateWithDMYYYY("1/0/2048");
        parseInvalidDateWithDDMMYY("30/13/74");
        parseInvalidDateWithDDMMYYY("11/11/100");
        parseInvalidDateWithDDMMYYYY("1/1/10000");
        parseValidDateWithYYYYMD("0000/1/1");
        parseValidDateWithYYYYMMDD("9999/12/31");
        parseInvalidDateWithYYYMDD("999/9/10");
        parseInvalidDateWithYYYYYMMDD("10000/11/11");
        parseInvalidDateWithYYYYMD("8888/5/0");
        parseInvalidDateWithYYYYMDD("1024/8/32");

    }

    private void parseInvalidDateWithYYYYMDD(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithYYYYMD(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithYYYYYMMDD(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithYYYMDD(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseValidDateWithYYYYMMDD(String source) {
        DateParser dateParser = new DateParser();
        assertTrue(dateParser.tryParse(source));

        assertEquals(dateParser.getEndDate(), LocalDate.of(9999, 12, 31));
    }

    private void parseValidDateWithYYYYMD(String source) {
        DateParser dateParser = new DateParser();
        assertTrue(dateParser.tryParse(source));

        assertEquals(dateParser.getEndDate(), LocalDate.of(0000, 1, 1));
    }

    private void parseInvalidDateWithDDMMYYYY(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithDDMMYYY(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithDDMMYY(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithDMYYYY(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithDDMYYYY(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseInvalidDateWithDMYY(String source) {
        DateParser dateParser = new DateParser();
        assertFalse(dateParser.tryParse(source));
    }

    private void parseValidDateWithDDMMYYYY(String source) {
        DateParser dateParser = new DateParser();
        assertTrue(dateParser.tryParse(source));
        assertEquals(dateParser.getEndDate(), LocalDate.of(0, 11, 12));
    }

    private void parseValidDateWithDDMYY(String source) {
        DateParser dateParser = new DateParser();
        assertTrue(dateParser.tryParse(source));

        assertEquals(dateParser.getEndDate(), LocalDate.of(2099, 9, 10));
    }

    private void parseValidDateWithDDMMYY(String source) {
        DateParser dateParser = new DateParser();
        assertTrue(dateParser.tryParse(source));

        assertEquals(dateParser.getEndDate(), LocalDate.of(9999, 12, 31));
    }

    private void parseValidDateWithDMY(String source) {
        DateParser dateParser = new DateParser();
        assertTrue(dateParser.tryParse(source));

        assertEquals(dateParser.getEndDate(), LocalDate.of(2000, 1, 1));
    }

}

	// End of segment: testCases\DateParserTest.java





	/**
	 * origin: testCases\ParserManagerTest.java
	 */

//@formatter:off
/**
 * For Flexible command testing:
 * 
 * Testing for all permutation for flexible command (4 words)
 * +-------------+-------------+-------------+-------------+
 * | command     | description | date        | priority    |
 * +-------------+-------------+-------------+-------------+
 * | command     | description | priority    | date        |
 * +-------------+-------------+-------------+-------------+
 * | command     | date        | description | priority    |
 * +-------------+-------------+-------------+-------------+
 * | command     | date        | priority    | description |
 * +-------------+-------------+-------------+-------------+
 * | command     | priority    | description | date        |
 * +-------------+-------------+-------------+-------------+
 * | command     | priority    | date        | description |
 * +-------------+-------------+-------------+-------------+
 * | description | command     | priority    | date        |
 * +-------------+-------------+-------------+-------------+
 * | description | command     | date        | priority    |
 * +-------------+-------------+-------------+-------------+
 * | description | date        | priority    | command     |
 * +-------------+-------------+-------------+-------------+
 * | description | date        | command     | priority    |
 * +-------------+-------------+-------------+-------------+
 * | description | priority    | date        | command     |
 * +-------------+-------------+-------------+-------------+
 * | description | priority    | command     | date        |
 * +-------------+-------------+-------------+-------------+
 * | date        | command     | description | priority    |
 * +-------------+-------------+-------------+-------------+
 * | date        | command     | priority    | description |
 * +-------------+-------------+-------------+-------------+
 * | date        | description | command     | priority    |
 * +-------------+-------------+-------------+-------------+
 * | date        | description | priority    | command     |
 * +-------------+-------------+-------------+-------------+
 * | date        | priority    | command     | description |
 * +-------------+-------------+-------------+-------------+
 * | date        | priority    | description | command     |
 * +-------------+-------------+-------------+-------------+
 * | priority    | command     | date        | description |
 * +-------------+-------------+-------------+-------------+
 * | priority    | command     | description | date        |
 * +-------------+-------------+-------------+-------------+
 * | priority    | description | date        | command     |
 * +-------------+-------------+-------------+-------------+
 * | priority    | description | command     | date        |
 * +-------------+-------------+-------------+-------------+
 * | priority    | date        | description | command     |
 * +-------------+-------------+-------------+-------------+
 * | priority    | date        | command     | description |
 * +-------------+-------------+-------------+-------------+
 
 * Testing for all permutation for flexible command (3 words)
 * +-------------+-------------+-------------+
 * | command     | date        | description |
 * +-------------+-------------+-------------+
 * | command     | description | date        |
 * +-------------+-------------+-------------+
 * | description | date        | command     |
 * +-------------+-------------+-------------+
 * | description | command     | date        |
 * +-------------+-------------+-------------+
 * | date        | description | command     |
 * +-------------+-------------+-------------+
 * | date        | command     | description |
 * +-------------+-------------+-------------+
 * | command     | priority    | description |
 * +-------------+-------------+-------------+
 * | command     | description | priority    |
 * +-------------+-------------+-------------+
 * | description | priority    | command     |
 * +-------------+-------------+-------------+
 * | description | command     | priority    |
 * +-------------+-------------+-------------+
 * | priority    | description | command     |
 * +-------------+-------------+-------------+
 * | priority    | command     | description |
 * +-------------+-------------+-------------+
 * 
 * Testing for all permutation for flexible command (2 words)
 * 
 * +-------------+-------------+
 * | command     | description |
 * +-------------+-------------+
 * | description | command     |
 * +-------------+-------------+
 */
//@formatter:on

public class ParserManagerTest {

    @Test
    public void test() {

        parseAddCommand();
        parseDeleteCommand();
        parseFlexibleOrdering();
        parseInvalidSplitDescription();

    }

    private void parseFlexibleOrdering() {
        String expectedDescription = "eat rice";
        LocalDate expectedEndDate = LocalDate.now();
        LocalTime expectedEndTime = LocalTime.of(15, 0);
        Priority expectedPriority = Priority.PRIORITY_HIGH;

        Task expectedTaskfor4Words = new Task(expectedDescription,
                expectedPriority, expectedEndDate, expectedEndTime);
        Task expectedTaskfor3WordsWithDate = new Task(expectedDescription,
                Task.PRIORITY_NOT_SET, expectedEndDate, expectedEndTime);
        Task expectedTaskfor3WordsWithPriority = new Task(expectedDescription,
                expectedPriority);
        Task expectedTaskfor2Words = new Task(expectedDescription,
                Task.PRIORITY_NOT_SET);

        String command = "add";
        String description = "eat rice";
        String date = "today 3pm";
        String priority = "pri high";

        // Testing for permutation of flexible command (refer to initial
        // comments)
        parseFlexibleAdd(expectedTaskfor4Words, command, description, date,
                priority);
        parseFlexibleAdd(expectedTaskfor4Words, command, description, priority,
                date);
        parseFlexibleAdd(expectedTaskfor4Words, command, date, description,
                priority);
        parseFlexibleAdd(expectedTaskfor4Words, command, date, priority,
                description);
        parseFlexibleAdd(expectedTaskfor4Words, command, priority, description,
                date);
        parseFlexibleAdd(expectedTaskfor4Words, command, priority, date,
                description);
        parseFlexibleAdd(expectedTaskfor4Words, description, command, priority,
                date);
        parseFlexibleAdd(expectedTaskfor4Words, description, command, date,
                priority);
        parseFlexibleAdd(expectedTaskfor4Words, description, date, priority,
                command);
        parseFlexibleAdd(expectedTaskfor4Words, description, date, command,
                priority);
        parseFlexibleAdd(expectedTaskfor4Words, description, priority, date,
                command);
        parseFlexibleAdd(expectedTaskfor4Words, description, priority, command,
                date);
        parseFlexibleAdd(expectedTaskfor4Words, date, command, description,
                priority);
        parseFlexibleAdd(expectedTaskfor4Words, date, command, priority,
                description);
        parseFlexibleAdd(expectedTaskfor4Words, date, description, command,
                priority);
        parseFlexibleAdd(expectedTaskfor4Words, date, description, priority,
                command);
        parseFlexibleAdd(expectedTaskfor4Words, date, priority, command,
                description);
        parseFlexibleAdd(expectedTaskfor4Words, date, priority, description,
                command);
        parseFlexibleAdd(expectedTaskfor4Words, priority, command, date,
                description);
        parseFlexibleAdd(expectedTaskfor4Words, priority, command, description,
                date);
        parseFlexibleAdd(expectedTaskfor4Words, priority, description, date,
                command);
        parseFlexibleAdd(expectedTaskfor4Words, priority, description, command,
                date);
        parseFlexibleAdd(expectedTaskfor4Words, priority, date, description,
                command);
        parseFlexibleAdd(expectedTaskfor4Words, priority, date, command,
                description);

        parseFlexibleAdd(expectedTaskfor3WordsWithDate, command, date,
                description);
        parseFlexibleAdd(expectedTaskfor3WordsWithDate, command, description,
                date);
        parseFlexibleAdd(expectedTaskfor3WordsWithDate, description, date,
                command);
        parseFlexibleAdd(expectedTaskfor3WordsWithDate, description, command,
                date);
        parseFlexibleAdd(expectedTaskfor3WordsWithDate, date, description,
                command);
        parseFlexibleAdd(expectedTaskfor3WordsWithDate, date, command,
                description);

        parseFlexibleAdd(expectedTaskfor3WordsWithPriority, command, priority,
                description);
        parseFlexibleAdd(expectedTaskfor3WordsWithPriority, command,
                description, priority);
        parseFlexibleAdd(expectedTaskfor3WordsWithPriority, description,
                priority, command);
        parseFlexibleAdd(expectedTaskfor3WordsWithPriority, description,
                command, priority);
        parseFlexibleAdd(expectedTaskfor3WordsWithPriority, priority,
                description, command);
        parseFlexibleAdd(expectedTaskfor3WordsWithPriority, priority, command,
                description);

        parseFlexibleAdd(expectedTaskfor2Words, command, description);
        parseFlexibleAdd(expectedTaskfor2Words, description, command);
        

    }
    
    

    private void parseInvalidSplitDescription() {
        String command = "add";
        String description = "eat rice";
        String date = "today 3pm";
        String priority = "pri high";
        
        parseSplitDescription(command, description, date ,description);
        parseSplitDescription(command, description, priority, date , description);
        parseSplitDescription(description, priority, date , description, command);
        parseSplitDescription(priority, description, date , description, command);

    }

    
    private void parseSplitDescription(String... flexibleOrdering) {

        String input = "";

        for (String set : flexibleOrdering) {
            input += (" " + set);
        }

       
        assertFailedMessage(input);

    }

    private void assertFailedMessage(String input) {
        final String FAILED_MESSAGE = "Description Should not be separeted";
        ParserManager parserManager = new ParserManager();
        assertEquals(FAILED_MESSAGE, parserManager.interpret(input).getFailedMessage());
    }

    private void parseFlexibleAdd(Task expectedTask, String... flexibleOrdering) {
        String input = "";

        for (String set : flexibleOrdering) {
            input += (" " + set);
        }

        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(input, expectedResult);

    }

    private void parseDeleteCommand() {
        parseValidDeleteWithIntegerRange();
        parseValidDeleteWithMultipleInteger();
        parseValidDeleteWithInteger();
        parseValidDeleteWithNegativeIntegerRange();
        parseValidDeleteWithMultipleNegativeInteger();
        parseValidDeleteWithNegativeInteger();
    }

    private void parseAddCommand() {
        parseValidAddWithNoDate();
        parseValidAddWith1DateAndPriority();
        parseValidAddWith2DateAndPriority();
        parseValidAddWithPriorityAndDate();
        parseValidAddWith2Date2TimeAndPriority();
        parseValidAddWithPriority2Date2Time();
        parseValidAddWith_Priority2Date2Time();
        parseValidPriorityWith2Date2TimeAndAdd();
        parseValidFormalDateWithPriorityAndAdd();
        parseValidFormalDateWithAddAndPriority();
        parseValidAddWithNumberDescriptionAndTime();
        parseValidAddBakeCookieBug();
        parseValidAddWithNumberEndingDescription();
        parseValidAddWithNumberFollowedByDate();
    }

    private void parseValidDeleteWithNegativeInteger() {
        Task expectedTask = new Task("-10", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new DeleteCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("delete -10", expectedResult);
    }

    private void parseValidDeleteWithMultipleNegativeInteger() {
        Task expectedTask = new Task("-2,-3,-10", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new DeleteCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("delete -2,-3,-10", expectedResult);
    }

    private void parseValidDeleteWithNegativeIntegerRange() {
        Task expectedTask = new Task("-2 to 10", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new DeleteCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("delete -2 to 10", expectedResult);
    }

    private void parseValidDeleteWithIntegerRange() {
        Task expectedTask = new Task("2 to 10", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new DeleteCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("delete 2 to 10", expectedResult);
    }

    private void parseValidDeleteWithMultipleInteger() {
        Task expectedTask = new Task("2,3,4,5 and 1,9", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new DeleteCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("delete 2,3,4,5 and 1,9", expectedResult);
    }

    private void parseValidDeleteWithInteger() {
        Task expectedTask = new Task("10", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new DeleteCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("delete 10", expectedResult);
    }

    private void parseValidAddWithNumberFollowedByDate() {
        Task expectedTask = new Task("meeting", Task.PRIORITY_NOT_SET,
                LocalDate.now(), LocalTime.of(3, 0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("add meeting 3 today", expectedResult);
    }

    private void parseValidAddWithNumberEndingDescription() {
        Task expectedTask = new Task("meeting3", Task.PRIORITY_NOT_SET,
                LocalDate.now(), Task.TIME_NOT_SET);
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("add meeting3 today", expectedResult);
    }

    private void parseValidAddBakeCookieBug() {
        Task expectedTask = new Task("bake cookies", Task.PRIORITY_NOT_SET,
                LocalDate.now(), Task.TIME_NOT_SET);
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("add bake cookies today", expectedResult);
    }

    private void parseValidAddWithNumberDescriptionAndTime() {
        Task expectedTask = new Task(
                "hello page 321 to 232 and pg 23123 to 21321",
                Task.PRIORITY_NOT_SET, LocalDate.now(), LocalTime.of(20, 0),
                LocalDate.now(), LocalTime.of(22, 0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "add hello page 321 to 232 and pg 23123 to 21321 at 8pm to 10 pm",
                expectedResult);

    }

    private void parseValidFormalDateWithAddAndPriority() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_MEDIUM, LocalDate.of(2014, 9, 18),
                LocalTime.of(14, 0), LocalDate.of(2014, 9, 22), LocalTime.of(2,
                        0));

        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "date 18/09 2pm to 22/9 2am add buy for me something priority med",
                expectedResult);

    }

    private void parseValidFormalDateWithPriorityAndAdd() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_MEDIUM, LocalDate.of(2014, 9, 18),
                LocalTime.of(14, 0), LocalDate.of(2014, 9, 22), LocalTime.of(2,
                        0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "18/09/14 14:00 to 22/9/14 2:00 med priority add buy for me something",
                expectedResult);
    }

    private void parseValidPriorityWith2Date2TimeAndAdd() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_MEDIUM, LocalDate.of(2014, 9, 18),
                LocalTime.of(14, 0), LocalDate.of(2014, 9, 22), LocalTime.of(2,
                        0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "med priority date 18/09/14 2pm to 22/9/14 2am add buy for me something",
                expectedResult);
    }

    private void parseValidAddWith_Priority2Date2Time() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_MEDIUM, LocalDate.of(2014, 9, 18),
                LocalTime.of(14, 0), LocalDate.of(2014, 9, 22), LocalTime.of(2,
                        0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "add buy for me something med priority date 18/09/14 2pm to 22/9/14 2am ",
                expectedResult);

    }

    private void parseValidAddWithPriority2Date2Time() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_MEDIUM, LocalDate.of(2014, 9, 18),
                LocalTime.of(14, 0), LocalDate.of(2014, 9, 22), LocalTime.of(2,
                        0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "add buy for me something priority med date 18 sept 2pm to 22 sept 2am ",
                expectedResult);
    }

    private void parseValidAddWith2Date2TimeAndPriority() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_MEDIUM, LocalDate.of(2014, 9, 18),
                LocalTime.of(14, 0), LocalDate.of(2014, 9, 22), LocalTime.of(2,
                        0));
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "add buy for me something date 18 sept 2pm to 22 sept 2am med priority",
                expectedResult);

    }

    private void parseValidAddWithPriorityAndDate() {
        Task expectedTask = new Task("i wan to eat this",
                Priority.PRIORITY_LOW, LocalDate.of(2014, 12, 12),
                Task.TIME_NOT_SET);
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("add i wan to eat this priority low on 12 dec",
                expectedResult);
    }

    private void parseValidAddWith2DateAndPriority() {
        Task expectedTask = new Task("buy for me something",
                Priority.PRIORITY_LOW, LocalDate.of(2014, 9, 12),
                Task.TIME_NOT_SET, LocalDate.of(2014, 9, 18), Task.TIME_NOT_SET);
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse(
                "add buy for me something date 12 sept to 18 sept priority low",
                expectedResult);
    }

    /**
     * 
     */
    private void parseValidAddWith1DateAndPriority() {

        Task expectedTask = new Task("momo", Priority.PRIORITY_HIGH,
                LocalDate.of(2014, 9, 12), Task.TIME_NOT_SET);
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);

        assertValidParse("add momo by 12 sept priority high", expectedResult);
    }

    private void parseValidAddWithNoDate() {
        Task expectedTask = new Task("floating task", Task.PRIORITY_NOT_SET);
        Command expectedCommand = new AddCommand();
        ParseResult expectedResult = new ParseResult(expectedCommand,
                expectedTask);
        assertValidParse("add floating task", expectedResult);
    }

    private void assertValidParse(String input, ParseResult expectedResult) {
        ParserManager parserManager = new ParserManager();
        getNextUniqueID(expectedResult);
        assertEquals(expectedResult, parserManager.interpret(input));

    }

    private void getNextUniqueID(ParseResult expectedResult) {
        expectedResult.getTask().setUniqueID(Task.getCreateID());
    }
}

	// End of segment: testCases\ParserManagerTest.java





	/**
	 * origin: testCases\PriorityParserTest.java
	 */

//@formatter:off
/**
	// End of segment: testCases\PriorityParserTest.java





	/**
	 * origin: testCases\PriorityParserTest.java
	 */

 *
 * Priority Parser works by testing the first two words or the last two words of the String.
 * If either the first two words or the last two words contain the priority key words, tryParse function will return true. 
 * If both first and last two words are priority, the first two words will take precedence.
 * 
 * Listed below are the keywords for priority and the level of priority
 * They can be arranged in any permutation ( eg : priority high, high priority, high pri, etc)
 * Additionally, the key words are case insensitive 
 * +------------+-------------+------------+----------+
 * | Priority   | High        | Medium     | Low      |
 * +------------+-------------+------------+----------+
 * | "priority" | "high"      | "medium"   | "low"    |
 * +------------+-------------+------------+----------+
 * | "pri"      | "urgent"    | "med"      | "none"   |
 * +------------+-------------+------------+----------+
 * |            | "top"       | "normal"   | "no"     |
 * +------------+-------------+------------+----------+
 * |            | "crucial"   | "neutral"  | "zero"   |
 * +------------+-------------+------------+----------+
 * |            | "important" | "moderate" | "ignore" |
 * +------------+-------------+------------+----------+
 * 
 * Please delete the generate table comment:
 * To generate the table use : http://www.tablesgenerator.com/text_tables#
 * 
 */
//@formatter:on

public class PriorityParserTest {

    @Test
    public void test() {
        parseValidPriorityWithTwoWords("pri urgent");
        parseValidPriorityWithMoreThanTwoWords("hey priority ignore");

        parseInvalidPriorityWithTwoWords("sec high");
        parseInvalidPriorityWithLessThanTwoWords("high");
    }

    private void parseInvalidPriorityWithLessThanTwoWords(String source) {
        PriorityParser priorityParser = new PriorityParser();
        assertFalse(priorityParser.tryParse(source));
    }

    private void parseInvalidPriorityWithTwoWords(String source) {
        PriorityParser priorityParser = new PriorityParser();
        assertFalse(priorityParser.tryParse(source));
    }

    private void parseValidPriorityWithMoreThanTwoWords(String source) {
        PriorityParser priorityParser = new PriorityParser();
        assertTrue(priorityParser.tryParse(source));
        assertEquals(priorityParser.getPriority(), Priority.PRIORITY_LOW);
    }

    private void parseValidPriorityWithTwoWords(String source) {
        PriorityParser priorityParser = new PriorityParser();
        assertTrue(priorityParser.tryParse(source));
        assertEquals(priorityParser.getPriority(), Priority.PRIORITY_HIGH);
    }

}

	// End of segment: testCases\PriorityParserTest.java





	/**
	 * origin: testCases\TestLogicManager.java
	 */

/**
 *
 */
public class TestLogicManager {

    BasicDataHandler dataHandler = new BasicDataHandler();
    LogicManager logicManager = new LogicManager(dataHandler);
    ObservableList<Task> expectedList = new ObservableList<Task>(
            new ArrayList<Task>());

    @Test
    public void test() throws InvalidCommandException {
        expectedList = cloneList(dataHandler.getObservableList());

        processValidAdd10Task();
        processValidAddCommand("add hello today", new Task("hello",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add yoyo today priority high", new Task("yoyo",
                Priority.PRIORITY_HIGH, LocalDate.now(), Task.TIME_NOT_SET));
        processValidRemoveCommandForIndividualTask("remove 4", 4);
        processValidRemoveCommandForMultipleTask("remove 2-5", 2, 3, 4, 5);
        processValidAdd10Task();
        processValidRemoveCommandForMultipleTask(
                "remove 1-3 and 8,9 hmm 4 too plus 6", 1, 2, 3, 8, 9, 4, 6);
        
    }

    private void processValidAdd10Task() throws InvalidCommandException {
        processValidAddCommand("add more task today", new Task("more task",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task2 today", new Task("task2",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task3 today", new Task("task3",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task4 today", new Task("task4",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task5 today", new Task("task5",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task6 today", new Task("task6",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task7 today", new Task("task7",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task8 today", new Task("task8",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task9 today", new Task("task9",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
        processValidAddCommand("add task10 today", new Task("task10",
                Task.PRIORITY_NOT_SET, LocalDate.now(), Task.TIME_NOT_SET));
    }

    private void processValidRemoveCommandForMultipleTask(String command,
            Integer... indexArray) throws InvalidCommandException {
        final int ARRAY_OFFSET = 1;
        List<Integer> indexList = Arrays.asList(indexArray);
        Collections.sort(indexList);
        Collections.reverse(indexList);

        for (int index : indexList) {
            index = index - ARRAY_OFFSET;
            expectedList.remove(index);
        }
        ParseResult parseResult = logicManager.interpret(command);
        logicManager.executeCommand(parseResult);
        assertEquals(expectedList, dataHandler.getObservableList());
    }

    private void processValidRemoveCommandForIndividualTask(String command,
            int index) throws InvalidCommandException {
        final int ARRAY_OFFSET = 1;
        index = index - ARRAY_OFFSET;
        expectedList.remove(index);
        ParseResult parseResult = logicManager.interpret(command);
        logicManager.executeCommand(parseResult);
        assertEquals(expectedList, dataHandler.getObservableList());
    }

    private void processValidAddCommand(String command, Task expectedTask)
            throws InvalidCommandException {

        expectedTask = setNextUniqueID(expectedTask);
        expectedList.add(expectedTask);
        ParseResult parseResult = logicManager.interpret(command);
        logicManager.executeCommand(parseResult);
        assertEquals(expectedList, dataHandler.getObservableList());
    }

    private Task setNextUniqueID(Task expectedTask) {
        expectedTask.setUniqueID(Task.getCreateID());
        return expectedTask;
    }

    private ObservableList<Task> cloneList(ObservableList<Task> displayList) {
        ObservableList<Task> clonedList = new ObservableList<Task>(
                new ArrayList<Task>());

        for (Task task : displayList.getList()) {
            clonedList.add(new Task(task));
        }

        return clonedList;
    }

}

	// End of segment: testCases\TestLogicManager.java





